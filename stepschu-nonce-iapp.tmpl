

    cli admin-partitions {
    	update-partition Common
    }
    sys application template /Common/stepschu-nonce.23.f5.ibd.cs {
    	actions {
    		definition {
    			html-help {
                <p><b>IBD Template</b></p>
<p>Use this iApp template to configure your BIG-IP to support F5 XC IBD and related F5 XC site security measures.</p>
<ul>
  <li>Before you configure your BIG-IP to work with IBD application, you must have subscribed to the F5 XC IBD service.</li>
  <li>For a complete walkthrough of this iApp, as well as detailed information and help, please visit https://f5cloudservices.zendesk.com/hc/en-us/articles/1500005614802.</li>
</ul>

<h6>SSE API Configuration</h6>
<p>
<h6>JavaScript Injection Configuration</h6>
<ul>
    <li><b>Shape JS Injection:</b> Enabled by default. If this setting is disabled, the Shape Security Solution cannot be implemented on your iApp.</li>
    <li><b>Inject JS tags at F5 layer:</b> Choose whether you want F5 to inject script tags or you want to do it manually.</li>
    <li><b>Shape JS URL or Path:</b> Enter the path you received from F5 support for the Shape JS injection.</li>
    <li><b>Location for Shape JS Injection:</b> From the drop-down list, select a location in the HTML code of your webpage for the Shape JS Injection.</li>
    <li><b>Async JS Injection:</b> When enabled, the BIG-IP injects Async JS in the HTML code of your webpage.</li>
    <li><b>Inject Telemetry JS in body tag:</b> Select Yes to inject the Telemetry JS in the body tag in the HTML code of your webpage. Note: If No is selected, the Telemetry JS is injected in the same location as the Shape JS.</li>
    <li><b>Inject Shape JS in specific webpages only:</b> Select Yes if you want to inject the Shape JS (and Async JS if enabled) in specific webpages of your web application. Select No to inject the Shape JS (and Async JS if enabled) in all webpages of your web application.</li>
    <li><b>JS Injection Paths:</b> If you set Inject Shape JS in specific webpages only = Yes, enter here the paths of the webpages in your application to receive the Shape JS (and Async JS if enabled) injections.</li>
    <li><b>Exclude Shape JS injection from specific webpages:</b> Select Yes if you want to exclude the Shape JS (and Async JS if enabled) from specific webpages in your web application.</li>
    <li><b>JS Excluded Paths:</b> If you set Exclude Shape JS injection from specific webpages = Yes, enter here the paths of the webpages in your application where the Shape JS (and Async JS if enabled) injections should be excluded.</li>
</ul>
<h6>Endpoints Configuration</h6>
<ul>
    <li><b>Mitigation Handler:</b> Choose 'iApp' if you want mitigation to be handled in the F5 layer.</li>
    <li><b>Shape protected host:</b> Enter your application host.</li>
    <li><b>Paths to be routed to Shape Security and mitigated by iApp:</b> Use these settings to configure which endpoints will be protected by SSE and mitigated by iApp.</li>
    <li><b>Endpoint:</b> Enter here the path to the web page you want to be protected by SSE. Note: The endpoint must be lowercase letters only and start with '/'.</li>
    <li><b>ANY:</b> Set this to Yes if you want the path to be protected with any type of method (i.e., GET, POST, or PUT). Set it to No if you want to limit protection to only a certain method(s).</li>
    <li><b>GET, POST, PUT:</b> Set Yes if you want the path protected when it has the selected method.</li>
    <li><b>Mitigation Action:</b> If you chose to handle the mitigation in the F5 layer, choose an action for malicious requests from this endpoint.</li>
</ul>
<h6>Mitigation Settings</h6>
<ul>
    <li><b>Redirect Path:</b> Enter here the path where all 'redirect' mitigation requests will be sent. This can be either a relative URL or a full URL (includes protocol). This field is mandatory if you chose Shape Policy for the Mitigation Handler or if at least one endpoint has Mitigation Action=Redirect.</li>
    <li><b>Block Data: </b>Choose the response code and body that you want to return for blocked requests. This field is mandatory if at least one endpoint has Mitigation Action=Block.</li>
    <li><b>Bot Header Name: </b>Enter here the header to add for flagged requests. This field is mandatory if at least one endpoint has Mitigation Action=Continue.</li>
</ul>
<h6>Pool Configuration</h6>
<ul>
    <li><b>Whitelist IP addresses:</b> Enter here the IPs for which mitigation will be disabled.</li>
    <li><b>Whitelist Header:</b> Enter here the request headers for which mitigation will be disabled.</li>
    <li><b>Traffic routing methodology:</b> Select whether you want the iApp pool to be routed according to the method. In this version, only the default method is supported.</li>
    <li><b>Shape Protection Pool:</b> Add here the IP or FQDN for every pool member of the SSE cluster. </li>
    <li><b>Add HTTP Health Check:</b> Choose whether to perform the HTTP Health Check on the entire pool. The HTTP Health Check is performed in intervals of 5 seconds.</li>
</ul>
<h6>API Request Settings</h6>
<ul>
    <li><b>API hostname:</b> Enter the API hostname you received from F5 support.</li>
    <li><b>Mobile-SDK API hostname:</b> Enter the Mobile-SDK API hostname you received from F5 support.</li>
    <li><b>API key:</b> Enter the API key you received from F5 support.</li>
    <li><b>Telemetry header prefix:</b> Enter the Telemetry header prefix you received from F5 support.</li>
    <li><b>Timeout value for API response (ms):</b> Set the length of time (in milliseconds) that the BIG-IP should wait to receive a response from the SSE after the BIG-IP sends the API request to the SSE.</li>
</ul>
<h6>Virtual Server Configuration</h6>
<ul>
    <li><b>Application's virtual server(s) to protect:</b> Select the virtual server(s) that your iApp runs on. Selecting one virtual server is mandatory.</li>
</ul>
<h6>Advanced Features Configuration</h6>
<ul>
    <li><b>Rewrite XFF header with Connecting IP:</b> Select Yes to add an XFF header to requests.</li>
    <li><b>Enable TLS fingerprint:</b> Select Yes to send API requests to the SSE with a TLS fingerprint.</li>
    <li><b>Choose server-side SSL profile for Shape pool:</b> select a suitable profile here.</li>
    <li><b>Encrypting Virtual Server IP:</b> A default IP is assigned. If you have a virtual server already configured to this IP, assign a different IP here.</li>
</ul>
</p>

}
    			implementation {
tmsh::log_dest file
tmsh::log_level err
tmsh::include "f5.app_utils"

proc ::iapp::debug { args } {
    # Passwords should be obscured in all logs. Fields shown here are handled
    # in this proc, but the global variable may be overwritten if alternate
    # fields should be obscured.
    if { ![info exists ::SENSITIVES] } {
        set ::SENSITIVES {
            account-password
            admin-encrypted-password
            bind-pw
            PASSWORD
            password
            passwd
            proxy-ca-passphrase
            secret
        }
    }

    # look for any of the sensitive words, and replace the word that follows it
    set regex "(\\m([join $::SENSITIVES |])\\M)\\s+\[^\\s\]*"
    regsub -all $regex [join $args] {\1 -OBSCURED-} args
    regsub -all "(<Password.*>).*(</Password>)" $args {\1-OBSCURED-\2} args

    set lev "debug"
    if { $lev eq {debug} } {
        puts $args
    }
}

package require base64

#------------------------------------------------

proc fail {err} {
 package require iapp 1.1.1

 set msg "\n______________________________________________________________\n\n"
 append msg "\n${err}\n\n" $msg

 error ${msg}

 iapp::debug "proc 'fail'-- should never get here!"
} ; #proc fail

# neither lappend nor lset does what we want, so...
proc lnew {name prime} {
 upvar $name n
 set n [expr {($prime ne "") ? [list $prime] : [list]}]
 return $n
} ; #proc lnew

set tmsh_specials "'\x22{};/|#\x20\x5c"
set ::tmsh_escape [list]
foreach {ch} [split $tmsh_specials ""] {
 lappend ::tmsh_escape "${ch}" "\x5c${ch}"
}

# Encode a string so it will trigger fewer bugs in TMSH
proc tmsh_escape {str} {
 set bb [list "\x5c" "\x5c\x5c" "#" "\x5c#" ]
 if {[string first "'" $str] < 0} { return "'[string map $bb $str]'" }
 if {[string first "\x22" $str] < 0} { return "\x22[string map $bb $str]\x22" }
 return [string map $::tmsh_escape $str]
} ; #proc tmsh_escape

# store some info in ASO
proc store {tag val} {
 package require iapp 1.1.1

 set tgt "::stash_${tag}"
 set verb [expr {[info exists [set tgt]] ? "modify" : "add"}]

 lnew c "modify /sys application service ${::myapp}"
 lappend c "variables ${verb} \x7b"
  lappend c "stash_${tag} { value [tmsh_escape $val] }"
 lappend c "\x7d"
 iapp::conf [join $c]

 return [set [set tgt] $val]
} ; #proc store

# retrieve some info
proc load {args} {
 set nullval ""
 if {[lindex $args 0] eq "-dfl"} {
  set nullval [lindex $args 1]
  set args [lreplace $args 0 1]
 }
 set tgt "::stash_[lindex $args 0]"
 return [expr {[info exists [set tgt]] ? [set [set tgt]] : $nullval}]
 #--does not distinguish empty-string value from unset
} ; #proc load

# compare against some stored info
proc compare {tag value} {
 return [expr {[load $tag] eq $value}]
} ; #proc compare

#------------------------------------------------

#glob2rex isn't perfect-- it mishandles [*?]
set ::glob2rex [list "." "\x5c." "?" "." "*" ".*" \
                     "^" "\x5c^" "$" "\x5c$" "(" "\x5c(" ")" "\x5c)" \
                     "+" "\x5c+" "|" "\x5c|" \
                     "\x7b" "\x5c\x7b" "\x7d" "\x5c\x7d" ]

#------------------------------------------------

# test whether named object exists in configuration
proc exists {target} {
 package require iapp 1.1.1
 return [expr {![catch {tmsh::get_config $target}]}]
} ; #proc exists

puts "======================== $tmsh::app_name LOG ============================="
#********************* Global Variables ***********************
set ::myapp $tmsh::app_name
set ::mypath [tmsh::pwd]
set ::mypartn [regsub {^/([^/]+).*$} $::mypath {\1}]

set ::myRD [lindex [tmsh::get_config "/ auth partition ${::mypartn} default-route-domain"] [list 0 3 1]]
set ::add_RD [expr {($::myRD == 0) ? "" : "%${::myRD}"}]

proc rd_partition {rd} {
    set rd_partn "Common" ; #default
    set rdnames [iapp::get_items -list net route-domain]
    foreach {rdname} $rdnames {
        set rdname [regsub {^.*(/[^/]+/[^/]+)$} $rdname {\1}]
        set tmp [tmsh::get_config "/ net route-domain ${rdname} id partition"]
        if {[lindex $tmp [list 0 3 1]] == $rd} {
            set rd_partn [lindex $tmp [list 0 3 3]]
            break
        }
    }
    return [regsub {^/?([^/]+).*$} $rd_partn {\1}]
} ; #proc rd_partition


set ::myTG [lindex [tmsh::get_config "/ sys folder /${::mypartn} traffic-group"] [list 0 3 1]]
if {[string range $::myTG 0 0] ne "/"} { set ::myTG "/Common/${::myTG}" }

set ::myCommonPrefix "/Common/F5XCC-${::mypartn}-${::myapp}-"

set ::iapp_name "/${::mypartn}/${::myapp}"
set ::iapp_prefix "/${::mypartn}/F5XCC-${::myapp}-"
set ::f5xcc_irule_name "${::iapp_prefix}iRule"
set ::html_js_rule_name "${::iapp_prefix}JSRule"
set ::html_iojs_rule_name "${::iapp_prefix}IOJSRule"
set ::f5xcc_inject_html_profile_name "${::iapp_prefix}JsHtml"
set ::sband_helper_irule_name "${::iapp_prefix}SBand-helper"
set ::helper_http_profile "${::iapp_prefix}helper_http_profile"
set ::helper_proxy_profile "${::iapp_prefix}helper_proxy_profile"
set ::helper_one_connect "${::iapp_prefix}helper_one_connect"
# ---------- f5xcc VS Configuration -----------------------------
set ::f5xcc_web_vs_name "${::iapp_prefix}web_vs"
set ::f5xcc_msdk_vs_name "${::iapp_prefix}msdk_vs"

set ::sband_proxy_connect_event {
when HTTP_PROXY_CONNECT {
    if {$proxy_auth_string ne ""} {
        HTTP::header remove Proxy-Authorization
        HTTP::header insert Proxy-Authorization "Basic ${proxy_auth_string}"
    }
}

when HTTP_PROXY_RESPONSE {
    if {[set status [HTTP::status]] eq "407"} {
        if {($api_request_type == 1) || ($api_request_type == 3)} {
            set rcv_bytes "PROXYAUTH"
            clientside { TCP::respond $rcv_bytes }
        } else {
            set resp_string "${status}:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX:0"
            clientside { TCP::respond $resp_string }
        }
    }
}
}

#################################################
######## SIDEBAND-helper iRule Start ###############
set ::sband_helper_irule   {

#== Sideband Helper ===========================
when HTTP_REQUEST {
    set debug [HTTP::header x-ibd-debug]
    HTTP::header remove x-ibd-debug

    set api_request_type [HTTP::header x-ibd-req-type]
    HTTP::header remove x-ibd-req-type
    set proxy_auth_string [HTTP::header x-ibd-proxy-auth]
    HTTP::header remove x-ibd-proxy-auth

    set txid [HTTP::header x-ibd-txid]
    HTTP::header remove x-ibd-txid

    set fetch [expr {[HTTP::header x-ibd-fetch] eq "direct"}]
    HTTP::header remove x-ibd-fetch

    if {[string length $debug] > 1} {
        log $debug "txid=${txid} api_req_typ=${api_request_type} fetch=${fetch}, req=[HTTP::request]"
    }

    if {[active_members [LB::server pool]] < 1} {
        if {!$fetch} {
            if {$api_request_type == 2} {
                #API request
                set x30 "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
                set resp_wedge "503:${x30}:${x30}:0X"
            } else {
                set resp_wedge "NOSERVERS"
            }
            clientside { TCP::respond $resp_wedge }
        }

        if {[string length $debug] > 1} {
            log $debug "txid=${txid} No API server pool members available"
        }

        HTTP::respond 503 content "no server available at this time (${txid})\r\n" Content-Type text/plain Retry-After 20 Connection close
        return
    }

    # remove headers that XC DE API server won't understand properly
    HTTP::header remove Connection
    HTTP::header remove Expect
    HTTP::header remove Range
    HTTP::header remove Trailer

    if {$fetch} {
        set vigil [after 4000 {
            catch { HTTP::respond 504 content "server timeout (${txid})\r\n" Content-Type text/plain Retry-After 10 Connection close }
            if {[string length $debug] > 1} {
                log $debug "txid=${txid} server timeout"
            }

        }]
    }
} ; #HTTP_REQUEST

when HTTP_REQUEST_RELEASE {
    #log local0.info "fired"

    if {$fetch} {
        #we will just pass response to client
        return
    }

    if {($api_request_type == 1) || ($api_request_type == 3)} {
        SSL::collect
    }
}

__PROXY_CONNECT_EVENT__


when LB_SELECTED {
    if {[string length $debug] > 1} {
        log $debug "txid=${txid} API server= [LB::server]"
    }
}

when SERVERSSL_DATA {
    # if {[string length $debug] > 1} {
    #     log $debug "txid=${txid} Current SSL payload= [SSL::payload]"
    # }
    binary scan [SSL::payload] a* payload_copy
    while {[set x [string first "\r\n\r\n" $payload_copy]] >= 0} {
        #log local0.info "Found end of headers at index ${x}"
        incr x 4
        if {[string range $payload_copy 9 11] eq "100"} {
            #log local0.info "absorbing unneeded 100-Continue from API server..."
            SSL::payload replace 0 $x ""
            set payload_copy [string range $payload_copy $x end]
        } else {
            set hdr_byte_len $x
            #log local0.info "API server headers (incl CRLF CRLF) octets = ${hdr_byte_len}"
            SSL::release
            break
        }
    }
} ; #SERVERSSL_DATA

when HTTP_RESPONSE {
    if {$fetch} {
        if {[info exists vigil]} { after cancel $vigil }

        if {([HTTP::status] != 200) || ($debug ne "")} {
            HTTP::header replace x-ibd-api-info "[IP::server_addr]_[TCP::server_port]"
        }

        return
    }

    if {($api_request_type == 1) || ($api_request_type == 3)} {
        set clen_hdr [HTTP::header Content-Length]
        set te_hdr [HTTP::header Transfer-Encoding]
        #log local0.info "Clen is '$clen_hdr' and te is '$te_hdr'."
        if {$clen_hdr equals ""} {
            if {!($te_hdr contains "chunked")} {
                set rcv_bytes $hdr_byte_len
            } else {
                set rcv_bytes "ISCHUNKED"
            }
        } elseif {$clen_hdr == 0} {
            set rcv_bytes $hdr_byte_len
        } else {
            set rcv_bytes [expr {$hdr_byte_len + $clen_hdr}]
        }
        #log local0.info "rcv_bytes is '$rcv_bytes'."

        set tmp [string length $rcv_bytes]
        set rcv_bytes "[string range "000000000" $tmp end]${rcv_bytes}"
        # if {[string length $debug] > 1} {
        #     log $debug "txid=${txid} Padded rcv_bytes= '${rcv_bytes}'"
        # }
        clientside { TCP::respond $rcv_bytes }
        return
    }
    #otherwise

    set status [HTTP::status]
    #api_request_type:2 = endpoint request
    set inference [HTTP::header inference]
    if {[string length $debug] > 1} {
        log $debug "txid=${txid} Inference= ${inference}"
    }
    set inference [string range [append inference "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"] 0 29]
    set automation_type [HTTP::header automation_type]
    if {[string length $debug] > 1} {
        log $debug "txid=${txid} Automation_type= ${automation_type}"
    }
    set automation_type [string range [append automation_type "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"] 0 29]
    set cookie_bytes 0
    set cookie_count 0
    set cookie_vals ""
    if {[HTTP::header exists set-cookie]} {
        foreach {cookie} [HTTP::header values set-cookie] {
            incr cookie_count
            incr cookie_bytes [string length $cookie]
            append cookie_vals "${cookie}@@"
        }
    }
    set cookie_quant [string range "${cookie_count}X" 0 1]

    set resp_string "${status}:${inference}:${automation_type}:${cookie_quant}"
    clientside { TCP::respond $resp_string }
    #log local0.info "cookie_count: $cookie_count"
    if {$cookie_count > 0}{
        set cookie_bytes [expr { $cookie_bytes + (2 * ($cookie_count - 1)) }]
        set padded_cookie_bytes [string range [append cookie_bytes "XXXXXXXX"] 0 7]
        clientside { TCP::respond $padded_cookie_bytes }
        set cookie_vals [string trimright $cookie_vals "@"]
        clientside { TCP::respond $cookie_vals }
    }
    clientside { TCP::close }
} ; #HTTP_RESPONSE
#== End of Sideband Helper ====================

}
#################################################
######## SIDEBAND-helper iRule End #################


######################################
######## XC Security iRule Start ########
# iRule to be applied to BIG-IP LTM/ASM
set ::f5xcc_sed_irule {
# Set the lowest priority to not disturb the Customer iRules
priority 1000

# format and send log messages to syslog or HSL
# we filter by log-level here
#
proc xlog {logctl sev msg {json ""}} {
    upvar sI1me sI1me

    if {![string is integer -strict [set nsev [string map [set "${sI1me}sevmap"] $sev]]]} {
        set nsev 6
    }

    set npri [expr {$nsev + (8 * [set "${sI1me}log_fac_nbr"])}]

    if {$npri > __LOG_PRI__} {
        return
    }

    foreach {hsl txid} $logctl { break }

    set val ""

    set now [clock seconds]
    set tstamp [clock format $now -format "%Y%m%dT%H%M%SZ" -gmt true]

    if {$hsl ne ""} {
        #rfc3164
        set yechh [clock format $now -format "%b %d %H:%M:%S"]
        if {[string range $yechh 4 4] eq "0"} {
            set yechh [string replace $yechh 4 4 "\x20"]
        }
        set tmp "unknown"
        regexp {^([^.]+)} $static::tcl_platform(machine) junk tmp
        append val "<${npri}>${yechh} ${tmp} F5XCC:\x20"
    }

    set msg [regsub -all {[\x09\x0a\x0d\x20]+} $msg "\x20"]
    set msg [regsub -all {[\x00-\x1f\x7f]} $msg "."]

    if {__LOG_JSON__} {
        append val "\x7b\x22severity\x22:\x22${sev}\x22"
        append val ",\x22timestamp\x22:\x22${tstamp}\x22"
        append val ",\x22machine\x22:\x22${static::tcl_platform(machine)}\x22"

        if {$txid ne ""} {
            append val ",\x22txn_id\x22:\x22${txid}\x22"
        }
        if {$json ne ""} {
            append val "," [string range $json 1 end-1] ; #strip outer curlies
        }
        if {$msg ne ""} {
            append val ",\x22msg\x22:"
            set esc [list "\x5c" "\x5c\x5c" "\x22" "\x5c\x22"]
            append val "\x22[string map $esc $msg]\x22"
        }
        append val "\x7d"
    } else {
        if {$hsl ne ""} {
            append val "timestamp: ${tstamp}"
            append val "; machine: ${static::tcl_platform(machine)}"
        }
        if {$txid ne ""} {
            if {$hsl ne ""} { append val ";\x20" }
            append val "txn_id: ${txid}"
        }
        if {$msg ne ""} { append val ";\x20" }
        append val $msg
    }

    if {$hsl eq ""} {
        log "[set "${sI1me}log_fac"].${sev}" $val
        return
    }
    #otherwise

    HSL::send $hsl "${val}\n"
} ; #proc xlog


# generate a log message for each request/transaction
#
proc log_tx {logctl args} {
    upvar sI1me sI1me

    upvar txdata txdata
    array set txdata $args

    set z [list]
    lappend z program [list "__IAPP_NAME__ (__IAPP_VERSION__)"]

    foreach {k} [array names txdata] {
        if {$txdata($k) ne ""} {
            # skip elements that get special handling below
            if {($k eq "stms") || ($k eq "done") || ($k eq "benign")} {
                continue
            }

            set nbr [expr {[string last ":n" $k] == ([string length $k]-2)}]
            lappend z [expr {$nbr ? [string range $k 0 end-2] : $k}]
            lappend z [expr {$nbr ? [list $txdata($k) n] : [list $txdata($k)]}]
        }
    }

    if {[info exists txdata(stms)] && ($txdata(stms) ne "")} {
        lappend z req_ms
        lappend z [list [expr {[clock clicks -milliseconds] - $txdata(stms)}] n]
    }
    # proc xlog will attach transaction-ID

    set msg ""
    set json ""

    if {__LOG_JSON__} {
        set esc [list "\x5c" "\x5c\x5c" "\x22" "\x5c\x22"]

        set json "\x7b"
        set sep ""
        foreach {n v} $z {
            append json $sep "\x22${n}\x22:"
            if {[llength $v] == 1} {
                append json "\x22[string map $esc [lindex $v 0]]\x22"
            } else {
                ### if {[lindex $v 1] eq n}
                append json [lindex $v 0]
            }
            set sep ","
        }
        append json "\x7d"
    } else {
        set sep ""
        foreach {n v} $z {
            append msg $sep "${n}: [lindex $v 0]"
            set sep "; "
        }
    }

    set sev [expr {$txdata(benign) ? "info" : "warning"}]

    call xlog $logctl $sev $msg $json

    set txdata(done) true
} ; #log_tx


# TLS Fingerprint
# https://devcentral.f5.com/s/articles/tls-fingerprinting-a-method-for-identifying-a-tls-client-without-decrypting-24598
proc fingerprintTLS { dat rlen outer inner clientip serverip } {
    set ofs 43

    binary scan $dat @${ofs}c sessID_len
    set ofs [expr {$ofs + 1 + $sessID_len}]

    binary scan $dat @${ofs}S cl_len
    binary scan $dat @${ofs}H4 cl_len_hex
    set cl_len_hex_text $cl_len_hex

    set ofs [expr {$ofs + 2}]
    set cl_len_hex [expr {$cl_len * 2}]
    binary scan $dat @${ofs}H${cl_len_hex} cipherlist

    set ofs [expr {$ofs + $cl_len}]
    binary scan $dat @${ofs}c compr_len
    set ofs [expr {$ofs + 1}]
    binary scan $dat @${ofs}H[expr {$compr_len * 2}] compr_type
    set ofs [expr {$ofs + $compr_len}]

    if {$ofs < $rlen} {
        set ofs [expr {$ofs + 2}]

        set ext_list ""

        set rlen [expr {$rlen + 1}]

        while { [expr {$ofs <= $rlen}] } {
            binary scan $dat @${ofs}H4 ext

            append ext_list $ext

            set ofs [expr {$ofs + 2}]

            binary scan $dat @${ofs}S ext_len

            set ofs [expr {$ofs + 2}]

            switch $ext {
                "000b" {
                    binary scan $dat @[expr {$ofs + 1}]H[expr {($ext_len - 1) * 2}] ext_data
                    set ec_point_format $ext_data
                }
                "000a" {
                    binary scan $dat @[expr {$ofs + 2}]H[expr {($ext_len - 2) * 2}] ext_data
                    set ell_curves $ext_data
                }
                "000d" {
                    binary scan $dat @[expr {$ofs + 2}]H[expr {($ext_len - 2) * 2}] ext_data
                    set sig_alg $ext_data
                }
                default {
                    binary scan $dat @${ofs}H[expr {$ext_len * 2}] ext_data
                }
            }

            set ofs [expr {$ofs + $ext_len}]
        }
    }

    set cipl [string toupper $cl_len_hex_text]
    set ciph [string toupper $cipherlist]
    set coml $compr_len
    set comp [string toupper $compr_type]
    foreach {a b} [list ext_list exte ell_curves ecur sig_alg siga ec_point_format ecfp] {
        set [set b] [expr {([info exists $a] && ([set tmp [set [set a]]] ne "")) ?
                            [string toupper $tmp] : "@@@@"}]
    }

    return "${outer}+${inner}+${cipl}+${ciph}+${coml}+${comp}+${exte}+${ecur}+${siga}+${ecfp}"
}

proc insert_ibd_headers {xff msdk_req fp tls_fp ReqType istl_ept action debug logctl} {
    upvar sI1me sI1me
    upvar I1_cust_apikey I1_cust_apikey

    if {[HTTP::header exists apikey]} {
        set I1_cust_apikey [HTTP::header apikey]
        call xlog logctl debug "Won't send customer private header 'apikey' to API server"
        HTTP::header remove apikey
    }
    HTTP::header insert apikey [set "${sI1me}api_auth_key"]

    set pfx [set "${sI1me}api_prefix"]

    foreach {h} [list application-id tenant-id key ip host \
                      infrastructure-type connector txn-id timestamp \
                      path method type update-header fp] {
        HTTP::header remove "${pfx}${h}"
    }

    HTTP::header insert ${pfx}application-id [set "${sI1me}api_app_id"]
    HTTP::header insert ${pfx}tenant-id [set "${sI1me}tenant_id"]

    HTTP::header insert ${pfx}key [set "${sI1me}api_key"]
    HTTP::header insert ${pfx}ip ${xff}
    HTTP::header insert ${pfx}host [HTTP::header Host]
    #TODO: support IPv6 format here?? "[2001:db8::f5]:443"
    HTTP::header replace Host "[lindex [set "${sI1me}api_hosts"] $msdk_req]:443"

    HTTP::header insert ${pfx}infrastructure-type "BigIP"
    HTTP::header insert ${pfx}connector "Connector/0.1 (BigIP ${static::tcl_platform(osVersion)}-${static::tcl_platform(tmmVersion)}) iApp/__IAPP_VERSION__"
    HTTP::header insert ${pfx}txn-id [lindex $logctl 1]

    HTTP::header insert ${pfx}timestamp [clock format [clock seconds] -format "%a, %d %b %Y %H:%M:%S %Z" -gmt false]
    HTTP::header insert ${pfx}path [HTTP::path]
    HTTP::header insert ${pfx}method [HTTP::method]

    HTTP::header remove x-ibd-req-type
    HTTP::header insert x-ibd-req-type $ReqType
    HTTP::header remove x-ibd-txid
    HTTP::header insert x-ibd-txid [lindex $logctl 1]

    if {$istl_ept} {
        HTTP::header insert ${pfx}type [set "${sI1me}istl_header"]
    }
    if {$action ne ""} {
        HTTP::header insert ${pfx}mitigation-action $action
    }
    if {[set "${sI1me}use_proxy"] &&
         ([set tmp [set "${sI1me}proxy_auth_b64"]] ne "")} {
        HTTP::header remove x-ibd-proxy-auth
        HTTP::header insert x-ibd-proxy-auth $tmp
    }
    if {$msdk_req} {
        set tmp [set "${sI1me}msdk_reload_hdr"]
        HTTP::header insert ${pfx}update-header [expr {($tmp ne "") ? $tmp : "unknown"}]
    }
    if {$fp} {
        HTTP::header insert ${pfx}fp ${tls_fp}
    }
} ; #insert_ibd_headers

proc remove_ibd_headers {debug logctl} {
    upvar sI1me sI1me
    upvar I1_cust_apikey I1_cust_apikey

    if {[HTTP::has_responded]} { return }

    set pfx [set "${sI1me}api_prefix"]

    HTTP::header replace Host [HTTP::header ${pfx}host]
    foreach {h} [list application-id tenant-id key ip host infrastructure-type connector proto timestamp path method fp type mitigation-action update-header] {
        HTTP::header remove "${pfx}${h}"
    }
    if {[info exists I1_cust_apikey] && ($I1_cust_apikey ne "")} {
        HTTP::header replace apikey $I1_cust_apikey
        set I1_cust_apikey ""
    } else {
        HTTP::header remove apikey
    }
    foreach {h} [list req-type proxy-auth fetch debug txid] {
        HTTP::header remove "x-ibd-${h}"
    }

    if {[string tolower [HTTP::header inference]] eq "interstitial served"} {
        HTTP::header remove inference
    }
    HTTP::header remove istl-response
} ; #remove_ibd_headers

when LB_SELECTED {
    if {[info exists I1_direct] && ($I1_direct > 1)} {
        LB::reselect virtual [lindex [set "${sI1me}web_vs_list"] $I1_msdk_req]
        set I1_direct 1
    }
} ; #LB_SELECTED

when SERVER_CONNECTED {
    if {[info exists I1_direct] && $I1_direct} {
        catch { eval { [join [list "S" "SL::disable"] ""] } }
    }
} ; #SERVER_CONNECTED

proc ibd_api_call {ApiReq ApiPayload ApiReqType ApiIs_msdk debug logctl} {
    upvar sI1me sI1me
    upvar txdata txdata

    upvar I1_direct I1_direct

    set ApiTimeout [set "${sI1me}api_timeout"]

    upvar I1_ResHeaders ApiResHeaders
    upvar I1_ResBody ApiResBody
    upvar I1_Inference ApiInference
    upvar I1_Reason ApiReason
    upvar I1_Cookie ApiCookie
    upvar I1_CE ApiCE

    set ApiResHeaders [list]
    set ApiResBody {}
    set ApiInference "none, API call failed"
    set ApiReason ""
    set ApiCookie ""
    set ApiCE ""
    set ApiStatus 555 ; #just in case

    set ApiHelperVs [lindex [set "${sI1me}web_vs_list"] $ApiIs_msdk]
    if {$debug} {
        call xlog $logctl debug "start API call to [expr {$ApiIs_msdk ? "MSDK" : "WEB"}] API server via ${ApiHelperVs}"
    }

    if {$debug} {
        # IMPORTANT: helper-vs debug goes to local syslog, not HSL
        HTTP::header replace x-ibd-debug "[set "${sI1me}log_fac"].debug"
    }

    set begin_ms [clock clicks -milliseconds]

    #can we fetch JS directly?
    if {$ApiReqType == 1} {
        set I1_direct 2
        HTTP::header remove x-ibd-fetch
        HTTP::header insert x-ibd-fetch direct
        LB::detach
        return 999
    }

    set sts "unknown-error"
    for {} {1} {break} {
        if {[catch {connect -timeout 150 -idle 3 -status sts $ApiHelperVs} conn_id] ||
                ($conn_id eq "") || ($sts ne "connected")} {
          call xlog $logctl warning "connect to F5 XC API server via ${ApiHelperVs} failed, status='${sts}'"
          break
        }

        set tmp "${ApiReq}${ApiPayload}"
        if {[catch {send -timeout 500 -status sts $conn_id $tmp} req_bytes] ||
                ($sts ne "sent") || ($req_bytes != [string length $tmp])} {
          call xlog $logctl warning "send [string length $tmp]-byte request to API server failed, status='${sts}'"
          break
        }

        set init_pyld ""
        if {($ApiReqType == 1) || ($ApiReqType == 3)} {
            # Ensure timeout is between 1500 and 3000 for JS calls
            # Typically returns faster but need a "worst case" timeout
            if {($ApiTimeout < 1500) &&
                    ([set ApiTimeout [expr {8 * $ApiTimeout}]] > 3000)} {
                set ApiTimeout 3000
            }

            set recv_pyld ""
            set recv_len ""
            if {[catch {recv -timeout $ApiTimeout -status sts 9 $conn_id init_pyld}] ||
                    ($sts ne "received") || ([string length $init_pyld] != 9)} {
                call xlog $logctl warning "recv initial reply data from API server failed, wanted 9 bytes got [string length $init_pyld], status='${sts}'"
                break
            }
            if {$init_pyld eq "PROXYAUTH"} {
                set ApiStatus 407
                break
            }
            if {$init_pyld eq "NOSERVERS"} {
                set ApiStatus 503
                break
            }
            if {$init_pyld eq "ISCHUNKED"} {
                set next_len 1 ; #used for error-check below
                if {[catch {recv -timeout $ApiTimeout -status sts $conn_id recv_pyld} recv_len]} {
                    call xlog $logctl warning "recv chunked reply data from API server failed, result='${recv_len}', status='${sts}'"
                    break
                }
            } else {
                set next_len [string trimleft $init_pyld "0"]
                if {[catch {recv -timeout $ApiTimeout -status sts $next_len $conn_id recv_pyld} recv_len]} {
                    call xlog $logctl warning "recv reply data from API server failed, result='${recv_len}', status='${sts}'"
                    break
                }
            }
            if {![string is integer -strict $recv_len] || ($recv_len < $next_len) ||
                    (($sts ne "received") && ($sts ne "closed"))} {
                call xlog $logctl warning "recv reply data from API server failed, result='${recv_len}', status='${sts}'"
                break
            }

            #grab a binary copy of response so as to not alter payload
            binary scan $recv_pyld a* payload_copy

            set end_of_headers [string first "\r\n\r\n" $payload_copy]
            set start_of_body [expr {$end_of_headers + 4}]
            binary scan $payload_copy "@${start_of_body}a*" ApiResBody

            # parse headers from payload_copy
            set res_headers [string range $payload_copy 0 [incr end_of_headers -1]]
            set header_list [split [string map [list "\r\n" "\x00"] $res_headers] "\x00"]

            set res_status [regsub {^.*HTTP/[^ ]+ ([0-9]{3}).*$} [lindex $header_list 0] {\1}]
            set ApiStatus [expr {[string is integer -strict $res_status] ? $res_status : 555}]
            set header_list [lreplace $header_list 0 0]

            set ApiInference "" ; #need value from response, if any
            set client_res_headers [list]
            foreach {header} $header_list {
                foreach {h v} [split $header ":"] { break }
                if {[set h [string tolower $h]] eq ""} {
                    continue
                }
                set v [string trim $v "\x20"]

                switch -- $h {
                    "inference" {
                        set ApiInference [string tolower $v]
                    }
                    "automation_type" {
                        set ApiReason $v
                    }
                    "set-cookie" {
   #TODO: is this right? this is the only set-cookie header?
                        set ApiCookie $v
                    }
                }
                lappend client_res_headers $h $v
            }
            set ApiResHeaders $client_res_headers

            break
        }
        # otherwise

        #ApiReqType == 2 == endpoint request
        set next_pyld ""
        set final_pyld ""
        if {[catch {recv -timeout $ApiTimeout -status sts 68 $conn_id init_pyld}] ||
                ([string length $init_pyld] != 68) ||
                (($sts ne "received") && ($sts ne "closed"))} {
            call xlog $logctl warning "Recv initial reply data from API server failed, wanted 68 bytes got [string length $init_pyld], status='${sts}'"
            break
        }

        foreach {status inference reason cookie_count} [split $init_pyld ":"] { break }

        set ApiStatus [expr {[string is integer -strict $status] ? $status : 555}]
        set ApiInference [string tolower [string trimright $inference "X"]]
        set ApiReason [string trimright $reason "X"]
        set cookie_count [string trimright $cookie_count "X"]

        if {$cookie_count < 1} {
            # we are finished here
            break
        }
        if {[catch {recv -timeout $ApiTimeout -status sts 8 $conn_id next_pyld}] ||
                ([string length $next_pyld] != 8) || ($sts ne "received")} {
            call xlog $logctl warning "recv API response cookie length failed, expected 8 bytes got [string length $next_pyld], status='${sts}'"
            break
        }

        set cookie_bytes [string trimright $next_pyld "X"]

        if {[catch {recv -timeout $ApiTimeout -status sts $cookie_bytes $conn_id final_pyld}] ||
                ([string length $final_pyld] != $cookie_bytes) ||
                (($sts ne "received") && ($sts ne "closed"))} {
            call xlog $logctl warning "recv API response cookie value(s) failed, expected ${cookie_bytes} bytes got [string length $final_pyld], status='${sts}'"
            break
        }

        set ApiCookie $final_pyld
    } ; #bailout block

    # we're done with this connection
    # (hopefully OneConnect on ApiHelperVs will
    # save us from dire inefficiency)
    catch {close $conn_id}

    if {$ApiStatus == 407} {
        call xlog $logctl error "API call failed, proxy credentials [expr {
            ($ApiReq contains "x-ibd-proxy-auth") ?  "invalid" : "needed" }]"
    }
    if {$ApiStatus == 503} {
        call xlog $logctl warning "API call failed, no servers available"
        set ApiInference "none, no API servers available"
    }

    set txdata(api_ms:n) [expr {[clock clicks -milliseconds] - $begin_ms}]
    return $ApiStatus
} ; #ibd_api_call

proc remove_telem_headers {debug logctl} {
    upvar sI1me sI1me

    if {[HTTP::has_responded]} { return }

    # remove headers that match F5XCC prefix
    foreach {n} [HTTP::header names] {
        if { [string match -nocase [set "${sI1me}f5xccTP"] $n] ||
             [string match -nocase [set "${sI1me}istlTP"] $n] } {
            if {$debug} {
                call xlog $logctl debug "removing telemetry from [HTTP::method] request header: ${n}"
            }
            HTTP::header remove $n
        }
    }
} ; #remove_telem_headers

proc remove_telem_payload {http_payload http_ctype debug logctl} {
    upvar sI1me sI1me

    if {[HTTP::has_responded]} { return }

    if {($http_payload eq "") ||
        ($http_ctype ne "application/x-www-form-urlencoded")} {
        # no work to do
        return
    }
    #otherwise

    if {$debug} {
        call xlog $logctl debug "Removing telemetry from [HTTP::method] request body"
    }

    set newpayload [join [lsearch -all -inline -not -glob [split $http_payload "&"] [set "${sI1me}f5xccTP"]] "&"]

    binary scan $newpayload a* newpayload
    HTTP::payload replace 0 [HTTP::payload length] $newpayload
} ; #remove_telem_payload

proc filter_customer_payload {http_payload http_ctype debug logctl} {
    upvar sI1me sI1me

    if {($http_payload eq "") ||
            ($http_ctype ne "application/x-www-form-urlencoded")} {
        # API server only wants to see (filtered) form data
        if {$debug} {
            call xlog $logctl debug "[HTTP::method] request body not a web form so not sending it to API server"
        }
        return ""
    }

    if {not __FILTER_API_BODY__} {
        if {$debug} {
            call xlog $logctl debug "send unfiltered [HTTP::method] request body [string length $http_payload] octets to API server"
        }
        return $http_payload
    }

    set newpayload [join [lsearch -all -inline -glob [split $http_payload "&"] [set "${sI1me}f5xccTP"]] "&"]
    binary scan $newpayload a* newpayload
    if {$debug} {
        call xlog $logctl debug "send only [string length $newpayload] octets of telemetry from [HTTP::method] request body to API server"
    }
    return $newpayload
} ; #filter_customer_payload


proc get_f5xcc_allow {xff_ip client_ip debug logctl} {
    upvar sI1me sI1me

    set dg_allowed_ip "__ALLOW_IPS_DG__"
    if {[class exists $dg_allowed_ip] &&
        ( [class match $client_ip equals $dg_allowed_ip] ||
          (($xff_ip ne "") && [class match $xff_ip equals $dg_allowed_ip]) )} {

        if {$debug} {
            call xlog $logctl debug "allowed-ip: client $client_ip or XFF $xff_ip"
        }
        return 1
    }

    set hnames [HTTP::header names]
    foreach {row} [set "${sI1me}allow_headers"] {
        foreach {hrex vrex} $row { break }
        foreach {hdr} [lsearch -all -inline -regexp $hnames $hrex] {
            if {[lsearch -regexp [HTTP::header values $hdr] $vrex] >= 0} {
                if {$debug} {
                    call xlog $logctl debug "allowed-header '${hdr}' matched name '${hrex}' and value '${vrex}'"
                }
                return 1
            }
        }
    }

    return 0
} ; #get_f5xcc_allow

proc msdk_match {epm debug logctl} {
    upvar sI1me sI1me

    switch -- [string range $epm 1 1] {
     "_" {
        return 1
     }
     "h" {
        set hnames [HTTP::header names]
        foreach {row} [set "${sI1me}msdk_headers"] {
            foreach {hrex vrex} $row { break }
            foreach {hdr} [lsearch -all -inline -regexp $hnames $hrex] {
                if {[lsearch -regexp [HTTP::header values $hdr] $vrex] >= 0} {
                    if {$debug} {
                        call xlog $logctl debug "msdk-header '${hdr}' matched name '${hrex}' and value '${vrex}'"
                    }
                    return 1
                }
            }
        }
     }
     "b" {
        #ugh-- we can't decide until we scan body
        #2=msdk only if body-match, 3=msdk if body-match, else web
        return [expr {2 + ([string range $epm 0 0] eq "B")}]
     }
     default {
        call xlog $logctl err "invalid mobile endpoint match criterion"
     }
    }

    # no match
    return 0
} ; #msdk_match

#host arg must be lower-case
proc ep_wild_match {eplist host path exp_qry debug logctl} {
    upvar sI1me sI1me

    if {$debug} {
     call xlog $logctl debug "wild-match URL ${host} ${path} (${exp_qry}) to eplist ${eplist}"
    }

    foreach {row} [set "${sI1me}${eplist}"] {
        foreach {eph epp epq epm} [lindex $row 0] { break }
        set action [lindex $row 1]

        if {[regexp $eph $host] && [regexp $epp $path]} {
            if {($epq eq "") || [regexp $epq $exp_qry]} {
                #mobile 0=web only (dfl), 1=msdk only,
                # 2=if body-test then msdk-only,
                # 3=both, so msdk if body-test, else web
                set mobile 0
                if { ([set epx [string range $epm 0 0]] eq "") ||
                     ( ($epx eq "M") &&
                       [set mobile [call msdk_match $epm $debug $logctl]] ) ||
                     ( ($epx eq "B") &&
                       ([set mobile [call msdk_match $epm $debug $logctl]] > -1) ) } {
                    if {$action ne ""} {
                        return [list $mobile $action]
                    }
                }
            }
        }
    }

    #did not find any match
    return [list]
} ; #ep_wild_match


# caller must supply lower-case http_host without port number
# and normalized http_path, plus adjusted http_query
proc get_mitigation_action {http_method http_host http_path exp_qry debug logctl} {
    upvar sI1me sI1me

    if {$debug} {
        set debug_path [URI::decode $http_path]
        if {$exp_qry ne ""} { append debug_path "?${exp_qry}" }
    }

    # mitigation action
    set action [list]

    if {[regexp {^(GET|POST|PUT)$} $http_method]} {
        set found $http_method
        set action [call ep_wild_match "EP_${found}" $http_host $http_path $exp_qry $debug $logctl]
    }

    if {![llength $action]} {
        # no mitigation yet, so no per-method match, so check ANY match
        set found ANY
        set action [call ep_wild_match "EP_ANY" $http_host $http_path $exp_qry $debug $logctl]
    }

    if {[llength $action]} {
        if {$debug} {
            call xlog $logctl debug "Set mitigation '${action}' for ${found} endpoint: ${debug_path}"
        }

        return [list PROTECTED $action]
    }

    # If no protected endpoint, check for ISTL endpoint
    set action [call ep_wild_match "EP_ISTL" $http_host $http_path $exp_qry $debug $logctl]
    if {[llength $action]} {
        if {$debug} {
            call xlog $logctl debug "Set mitigation '${action}' for ISTL endpoint: ${debug_path}"
        }

        return [list ISTL $action]
    }

    # found no valid Protected or ISTL Endpoint
    if {$debug} {
        call xlog $logctl debug "No mitigation found for endpoint ${debug_path}"
    }

    return [list]
} ; #get_mitigation_action


proc f5xcc_mitigation_decision {miti Request Payload ReqType Is_msdk debug logctl} {
    upvar sI1me sI1me
    upvar txdata txdata
    upvar I1_direct I1_direct
    upvar I1_direct_op I1_direct_op

    if {$debug} {
        call xlog $logctl debug "API RequestType: $ReqType (is MSDK=${Is_msdk})"
        call xlog $logctl debug "API Request: $Request"
        call xlog $logctl debug "API Payload length=[string length $Payload]"
    }

    if {$Is_msdk} {
        set txdata(msdk_ept:n) 1
    }

    set I1_Status [call ibd_api_call $Request $Payload $ReqType $Is_msdk $debug $logctl]
    if {$debug} {
        call xlog $logctl debug "mitigation-decision- API status=${I1_Status}, Inference=${I1_Inference}"
    }

    if {$I1_Status == 999} {
        #handle 'direct' in HTTP_RESPONSE
        set I1_direct_op [expr {$Is_msdk ? "Unk MSDK" : "Web ISTL"}]
        return
    }

    set txdata(inference) $I1_Inference

    if {$I1_Status eq "200"} {
        set txdata(atmn_type) $I1_Reason

        if {$debug} {
            call xlog $logctl debug "mitigation_decision: [HTTP::method] uri [HTTP::uri -normalized] host [HTTP::header sed-api-host] xff [HTTP::header X-Forwarded-For] referer [HTTP::header Referer] inference ${I1_Inference} user-agt [HTTP::header User-Agent]"
        }

        # Mitigation action parameters
        #M_continue = HTTP header to be added to request
        #M_redirect = URL to put in 'Location' header
        #M_block_code = HTTP status for block, dfl 200
        #M_block_body = HTML payload for block

        if {$I1_Inference eq "malicious"} {
            set txdata(benign) false

            switch -- $miti {
                "continue" {
                    if {$debug} {
                        call xlog $logctl debug "INFO mitigation 'Flag and continue' autotype ${I1_Reason}"
                    }
                    # rebuild req headers, add "flag" header plus payload,
                    # send to Origin on next trip through HTTP_REQUEST
                    if {[set "${sI1me}M_continue"] ne ""} {
                        HTTP::header remove [set "${sI1me}M_continue"]
                        HTTP::header insert [set "${sI1me}M_continue"] $I1_Reason
                    }
                }
                "block" {
                    if {$debug} {
                        call xlog $logctl debug "INFO mitigation 'Block' autotype ${I1_Reason}"
                    }
                    #Add Set-Cookie headers to response
                    call log_tx $logctl req_result "reply block-message" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
                    set block_hdrs [list Cache-Control no-cache Connection close]

                    set tmp_block_rsp [set "${sI1me}M_block_body"]
                    set tmp_block_ptr "tmp_block_rsp"

                    lappend block_hdrs Content-Type [expr {([string first "<" $tmp_block_rsp] >= 0) ? "text/html" : ([regexp {^ *\x7b.*\x7d *$} $tmp_block_rsp] ? "application/json" : "text/plain")}]

                    foreach {cky} [HTTP::header values Set-Cookie] {
                        lappend block_hdrs Set-Cookie $cky
                    }
                    if {$Is_msdk &&
                        ([set tmp [set "${sI1me}msdk_reload_hdr"]] ne "")} {
                        lappend block_hdrs $tmp reload
                    }

                    eval "HTTP::respond [set "${sI1me}M_block_code"] -version auto content $${tmp_block_ptr} noserver ${block_hdrs}"

                    return "no_cookie"
                }
                "redirect" {
                    if {$debug} {
                        call xlog $logctl debug "INFO mitigation 'Redirect' autotype ${I1_Reason}"
                    }
                    #Add Set-Cookie header to response
                    call log_tx $logctl req_result "reply redirect" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
                    HTTP::respond 302 -version auto noserver Location [set "${sI1me}M_redirect"] Set-Cookie [HTTP::header Set-Cookie]
                    return "no_cookie"
                }
                "drop" {
                    if {$debug} {
                        call xlog $logctl debug "INFO mitigation 'Drop' autotype ${I1_Reason}"
                    }
                    call log_tx $logctl req_result "terminate connection" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
                    reject
                    return "no_cookie"
                }
            }
        } elseif {$I1_Inference eq "interstitial served"} {
            if {$debug} {
                call xlog $logctl debug "return ISTL challenge"
            }
            # Return interstitial challenge as response to client
            set resBody "I1_ResBody"
            call log_tx $logctl req_result "serve interstitial-JS" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
            eval "HTTP::respond 200 -version auto content $$resBody noserver $I1_ResHeaders"
            return "interstitial served"
        } else {
            # Human! Rebuild original Request, send to origin
            if {$debug} {
                call xlog $logctl debug "INFO mitigation 'Allow' autotype 'N/A' "
            }

            # retain cookie from API
            if {[info exists I1_Cookie] && ($I1_Cookie ne "")} {
                if {$debug} {
                    call xlog $logctl debug "Retain cookie from API --- $I1_Cookie"
                }
                return $I1_Cookie
            }
        }
        # End of inference handling
    } else {
        # Error cases; fail-allow branch
        if {$debug} {
            call xlog $logctl debug "Unexpected API server status: $I1_Status"
        }
    }
    return "no_cookie"
} ; #f5xcc_mitigation_decision


when RULE_INIT {
    set I1me "__MYAPP__" ; append I1me "_"
    set sI1me "static::${I1me}"
    set "${sI1me}updated" "__UPDATED__"

    #log facility
    if {([set nfac "__LOG_FAC__"] eq "") || ![string first "__" $nfac]} {
        set nfac 16
    }
    set "${sI1me}log_fac_nbr" $nfac
    array set facmap [list 1 user 6 lpr 7 news 8 uucp 11 ftp 16 local0 19 local3]
    set "${sI1me}log_fac" $facmap($nfac)
    set sevmap [list debug 7 info 6 notice 5 warning 4 warn 4 error 3 err 3 critical 2 crit 2 alert 1 emergency 0 emerg 0]
    set "${sI1me}sevmap" $sevmap

    #protected and interstitial/web-scraping endpoints lists
    set eplist [list]
    lappend eplist EP_GET "__GET_EP_DG__"
    lappend eplist EP_POST "__POST_EP_DG__"
    lappend eplist EP_PUT "__PUT_EP_DG__"
    lappend eplist EP_ANY "__ANY_EP_DG__"
    lappend eplist EP_ISTL "__ISTL_EP_DG__"

    foreach {n dg} $eplist {
        set myvar "${sI1me}${n}"
        set [set myvar] [list]

        set rows [list]
        if {($dg ne "") && [class exists $dg] && [set sz [class size $dg]]} {
            if {$sz < 2} {
                set rows [list [class get $dg]]
            } else {
                set rows [class get $dg]
            }
        }
        foreach {row} $rows {
            foreach {k v} $row { break }
            foreach {xept action} [split $v "~"] { break }
            set endpoint [binary format H* $xept]
            lappend [set myvar] [list [split $endpoint "#"] $action]
        }
    }

    #MSDK headers list (may be set in MSDK requests)
    #allow-headers (bypass on header value) list
    foreach {n dg} [list msdk_headers "__MSDK_HEADERS_DG__" allow_headers "__ALLOW_HEADER_DG__"] {
        set myvar "${sI1me}${n}"
        set [set myvar] [list]
        set rows [list]
        if {[class exists $dg] && [set sz [class size $dg]]} {
            if {$sz < 2} {
                set rows [list [class get $dg]]
            } else {
                set rows [class get $dg]
            }
        }
        foreach {row} $rows {
            foreach {k v} $row { break }
            foreach {a b} [split $v "~"] { break }
            set hrex [binary format H* $a]
            set vrex [binary format H* $b]
            lappend [set myvar] [list $hrex $vrex]
        }
    }

    #sl_matchers value (to download protected endpoints to JS)
    set myvar "${sI1me}sl_matchers"
    set [set myvar] "var __sl_matchers=\x5b"
    set dg "__PROTECTED_EP_DG__"
    set rows [list]
    if {[class exists $dg] && [set sz [class size $dg]]} {
        set rows [class get $dg]
        if {$sz < 2} { set rows [list $rows] }
    }
    set sep ""
    foreach {row} $rows {
        foreach {k v} $row { break }
        set entrypoint [binary format H* $v]
        append [set myvar] $sep $entrypoint
        set sep ","
    }
    append [set myvar] "\x5d;"

    # request path or host/path to get JS from API server
    set "${sI1me}js_inj_path" {__JS_INJ_PATH__}

    # do we perform JS injection?
    set "${sI1me}do_js_injection" {__JS_INJ_ENABLE__}
    # JS tag "include" paths (1st)
    set "${sI1me}js_inject_incl" {__JS_INJECT_INCL__}
    # JS tag "exclude" paths (2nd)
    set "${sI1me}js_inject_excl" {__JS_INJECT_EXCL__}

    # path?query's that should be in- or ex-cluded from JS injection
    foreach {n dg} [list JS_INCL "__INCL_JS_DG__" JS_EXCL "__EXCL_JS_DG__"] {
        set myvar "${sI1me}${n}"
        set [set myvar] [list]

        set rows [list]
        if {($dg ne "") && [class exists $dg] && [set sz [class size $dg]]} {
            if {$sz < 2} {
                set rows [list [class get $dg]]
            } else {
                set rows [class get $dg]
            }
        }
        foreach {row} $rows {
            foreach {k xv} $row { break }
            set v [binary format H* $xv]
            foreach {path query} [split $v "#"] { break }
            lappend [set myvar] [list $path $query]
        }
    }

    #mitigation action params
    set "${sI1me}M_continue" {__CONTINUE__}
    set "${sI1me}M_redirect" {__REDIRECT__}
    set "${sI1me}M_block_code" {__BLOCK_CODE__}
    #route block-page content through datagroup to avoid
    #chance of exceeding 64K limit on iRule size
    set myvar "${sI1me}M_block_body"
    set [set myvar] {}
    set dg "__BLOCK_BODY_DG__"
    if {[class exists $dg] && [set sz [class size $dg]]} {
        set [set myvar] [class lookup 0 $dg]
    }

    # rewrite XFF header with connecting IP?
    set "${sI1me}rewrite_xff" __XFF__

    # prompt reply to Expect: 100 ?
    set "${sI1me}expect_100" __XPCT100__

    # "kill switch" == bypass of F5XC API (1=yes, 0=no)
    set "${sI1me}kill_switch" __KILL_SWITCH__

    # FQDNs of F5XC API servers
    set "${sI1me}api_hosts" [list "__CLUSTER_FQDN__" "__MSDK_API_FQDN__"]
    #set F5XC API timeout ms
    set "${sI1me}api_timeout" __TIMEOUT__

    set "${sI1me}web_vs_list" [list "__SHAPE_WEB_VS_NAME__" "__SHAPE_MSDK_VS_NAME__"]

    set "${sI1me}api_app_id" "__API_APPLICATION_ID__"

    set "${sI1me}api_key" "826dd4bdad8e43e3bd20d033c1645559"
    set "${sI1me}tenant_id" "f5-emea-ent-bceuutam"
    set "${sI1me}api_auth_key" "l754d_3zPRUpwWbWhkac6qcRAX9TFCe3oBb_JU7uji0"

    # xxxTP is always used with glob * appended
    set "${sI1me}f5xccTP" "Xa4vrhYP3Q-*"
    set "${sI1me}istlTP" "ISTL-*"

    set "${sI1me}api_prefix" "sed-api-"
    set "${sI1me}istl_header" "ISTL Protected"

    #is Mobile SDK support enabled?
    set "${sI1me}do_msdk" [expr {[string length "__MSDK_ENABLE__"] < 15}]
    set "${sI1me}msdk_reload_hdr" "__MSDK_RELOAD_HDR__"

    set "${sI1me}use_proxy" __USE_PROXY__
    set "${sI1me}proxy_auth_b64" "__PROXY_AUTH_B64__"

    set "${sI1me}qry_map" [list \
            "%22" "\x22" "%27" "'" "%3A" ":" "%3C" "<" "%3E" ">" \
            "%5B" "\x5b" "%5C" "\x5c" "%5D" "\x5d" "%5E" "^" "%60" "`" \
            "%7B" "\x7b" "%7C" "|" "%7D" "\x7d" "%7E" "~" ]

    unset -nocomplain I1me sI1me
} ; #RULE_INIT


when CLIENT_ACCEPTED {
    set I1me "__MYAPP__" ; append I1me "_"
    set sI1me "static::${I1me}"

    # every HTTP_REQUEST from client will get a new
    # probabilistically-unique transaction-ID...
    #
    # Note: these are NOT cryptographically unpredictable
    # DO NOT USE TRANSACTION-ID AS A CRYPTOGRAPHIC KEY OR NONCE
    # (cmp_unit in counter key averts cross-TMM IPC)
    set txid_ctr_key "ibdv3>[virtual]>[TMM::cmp_unit]"
    set txid_base "[clock seconds]_[ROUTE::domain]_[IP::local_addr]_"
    append txid_base $txid_ctr_key "_[IP::client_addr]_[TCP::client_port]_"

    # prepare to log per-request/transaction data
    array set txdata [list vs [virtual] done false]
    set txdata(src_ip) [IP::client_addr]
    set txdata(src_port:n) [TCP::client_port]
    set txdata(app_id) [set "${sI1me}api_app_id"]
    set txdata(benign) true ; #until we learn otherwise

    #TODO: restore after ID1104073 analysis
    ##if {[catch {whereis [IP::client_addr] continent country state city isp org proxy_type} tmp]} {
    ##    set tmp [list "" "" "" "" "" "" ""]
    ##}
    ##set txdata(client_geo) [join $tmp ":"]

    # in case we cannot get a better RTT estimate later, save early one
    set txdata(tcp_rtt:n) [expr {round([TCP::rtt]/32.0+0.5)}]

    #Configurable part
    # Log debug messages?
    set v_debug __DEBUG__

    set hsl "" ; #default to normal logging
    if {[set hsl_pub "__HSL_PUB__"] ne ""} {
        if {[catch {HSL::open -publisher $hsl_pub} hsl]} {
            log local0.err "Cannot open HSL publisher ${hsl_pub} (${hsl})"
            set hsl ""
        }
    }
    set logctl [list $hsl ""]

    set I1_sent_to_API 0

    # get TLS fingerprint?
    set I1_fp 0
    set I1_tls_fp "NOT_COLLECTED"
    if {[PROFILE::exists clientssl]} {
        set I1_fp 1

        TCP::collect
    }

    if {$v_debug} {
        call xlog $logctl debug "client: [IP::client_addr]_[TCP::client_port]"
    }
} ; #CLIENT_ACCEPTED

__CLIENTSSL_HANDSHAKE_EVENT__

when CLIENT_DATA {
  if {$I1_fp} {
    if {$v_debug} {
      call xlog $logctl debug "TLS fingerprint scan"
    }
    # Get the TLS packet type and versions
    if {![info exists I1_tls_fp_rlen]} {
        set outer_sslver [set rilen [set inner_sslver ""]]
        set rtype [set I1_tls_fp_rlen [set hs_type 0]]
        binary scan [TCP::payload] cH4ScH6H4 rtype outer_sslver I1_tls_fp_rlen hs_type rilen inner_sslver

        if {($rtype == 22) && ($hs_type == 1)} {
            # This is a TLS ClientHello (22 = TLS handshake, 1 = ClientHello)
            # get fingerprint
            set I1_tls_fp [call fingerprintTLS [TCP::payload] $I1_tls_fp_rlen $outer_sslver $inner_sslver [IP::client_addr] [IP::local_addr] ]
        }
        unset outer_sslver rilen inner_sslver rtype hs_type
    }
  }
  TCP::release
} ; #CLIENT_DATA

when HTTP_REQUEST priority 950 {
    # create per-req transaction ID (96 bits in base64url)
    # DO NOT USE THIS AS A CRYPTOGRAPHIC KEY OR NONCE
    #
    set stms [clock clicks -milliseconds]
    binary scan [sha1 "${txid_base}[table incr $txid_ctr_key]_[HTTP::request_num]_${stms}"] a12 tmp
    set txid [string map [list "+" "-" "/" "_"] [string trim [b64encode $tmp] =]]
    lset logctl 1 $txid

    set txdata(stms) $stms
    set txdata(req_start) [clock format [clock seconds] -format "%Y%m%dT%H%M%SZ" -gmt true]
    set txdata(benign) true ; #until we learn otherwise

    if {[set tmp {__XLOG_HDRS__}] ne ""} {
        foreach {n} [lsearch -all -inline -regexp [HTTP::header names] $tmp] {
            if {[HTTP::header count $n] > 1} {
                set v [string trim [join [HTTP::header values $n] "\x20|\x20"]]
            } else {
                set v [string trim [HTTP::header $n]]
                if {[string is double -strict $v]} {
                    set v [string trim $v "0"]
                    if {[string range $v end end] eq "."} { append v "0" }
                    append n ":n"
                }
            }
            set txdata(http_hdr_[string tolower $n]) $v
        }
        unset -nocomplain n v
    }

    if {[HTTP::has_responded]} {
        # some other iRule has already responded (oops!)
        set I1_f5xcc_working 0
        call xlog $logctl err "XCC Cannot process HTTP request because customer iRule already responded to client"
        call log_tx $logctl req_result "preempted by customer iRule" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
        return
    }
    #otherwise...

    set I1_f5xcc_working 1
    set txdata(done) false

    if {$v_debug} {
        call xlog $logctl debug "HTTP method: [HTTP::method], uri: [HTTP::uri]"
        call xlog $logctl debug "TLS fingerprint= ${I1_tls_fp}"
    }

    #---------- specific hack to resolve ibd and apg iapps conflict
    set shp_global_request_ibd_processed 0
    #----------

    set I1_xff ""

    set I1_byp "sent"
    set I1_sent_to_API 0
    set I1_req_type 0 ; # 0=unprotected; 1=JS/content fetch; 2=protected; 3=ISTL
    set I1_istl_endpt false
    set I1_action ""
    set I1_protect_pending_body [list]

    set I1_http_payload ""
    set I1_norm_path [HTTP::path -normalized]

    set I1_norm_query [HTTP::query -normalized]
    # replace some %XX urlencodings with actual chars
    set I1_exp_qry [string map [set "${sI1me}qry_map"] $I1_norm_query]

    set I1_http_host [string tolower [HTTP::host]]
    set I1_http_hostname [regsub {:[0-9]*$} $I1_http_host ""]
    set I1_f5xcc_cookie ""
    set I1_http_method [HTTP::method]

    set I1_http_ctype [string tolower [HTTP::header Content-Type]]

    set txdata(http_host) $I1_http_host
    if {[info exists I1_tls_sni] &&
          ($I1_tls_sni ne "") &&
            ($I1_tls_sni ne $I1_http_hostname)} {
        set txdata(tls_sni) $I1_tls_sni
    }
    set tmp [HTTP::uri -normalized]
    if {[set len [string length $tmp]] > 255} {
        set t2 [string range $tmp 0 191]
        append t2 "#" [expr {$len - 255}] "#"
        append t2 [string range $tmp end-62 end]
        set tmp $t2
    }
    set txdata(http_uri) $tmp
    unset -nocomplain tmp len t2

    set txdata(http_method) [HTTP::method]
    set txdata(http_ver:n) [HTTP::version]
    set txdata(http_ctr:n) [HTTP::request_num]

    set I1_js_inj_excluded 0
    set I1_js_inj_io_done 0
    set I1_js_inj_tel_done 0

    set I1_METHOPT [expr {[HTTP::method] eq "OPTIONS"}]

    set I1_direct 0

    for {} {![set "${sI1me}kill_switch"]} {break} {
        # Insert XFF header?
        if {[set "${sI1me}rewrite_xff"]} {
            set tmp [getfield [IP::client_addr] % 1]
            if {$v_debug} {
                call xlog $logctl debug "XFF rewrite to ${tmp}"
            }
            HTTP::header replace X-Forwarded-For $tmp
            set I1_xff $tmp
        }

        if {$I1_METHOPT} { break }

        # did client send Expect:100 ? (old cURL versions stupidly always do)
        if {(($I1_http_method eq "POST") || ($I1_http_method eq "PUT")) &&
              [set "${sI1me}expect_100"] &&
                ([HTTP::header Expect] ne "")} {
            HTTP::header remove "Expect"
            set yeah "HTTP/1.1 100 Continue\r\n\r\n"
            if {$I1_fp} {
                catch { eval { [join [list "SSL" "::respond \$repl"] ""] } }
            } else {
                TCP::respond $repl
            }
            unset yeah
        }

        if {[set "${sI1me}do_msdk"] &&
                [regexp {^/v1/(ios|android)/update/?$} $I1_norm_path]} {
            set I1_norm_path [string trimright $I1_norm_path "/"]
            # route calls for config update to MSDK API server
            set I1_sent_to_API 1
            set I1_req_type 1
            set I1_msdk_req 1 ; #send to MSDK API

            call insert_ibd_headers $I1_xff $I1_msdk_req $I1_fp $I1_tls_fp $I1_req_type $I1_istl_endpt $I1_action $v_debug $logctl

            if {$v_debug} {
                call xlog $logctl debug "Send MSDK update-config request to MSDK API"
            }
            set I1_Payload ""
            set I1_Request [HTTP::request]

            set I1_Status [call ibd_api_call $I1_Request $I1_Payload $I1_req_type $I1_msdk_req $v_debug $logctl]

            if {$I1_Status == 999} {
                #handle 'direct' in HTTP_RESPONSE
                set I1_direct_op "MSDK config update"
                return
            }

            #status 200 send to client
            if {$I1_Status == 200} {
                set resBody "I1_ResBody"
                call log_tx $logctl req_result "reply MSDK-config-update, [string length $resBody] octets" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
                eval "HTTP::respond 200 -version auto content $$resBody noserver $I1_ResHeaders"
            } else {
                # when API status not 200 respond 204 No Content
                if {$v_debug} {
                    call xlog $logctl debug "MSDK config update failed status $I1_Status Sent 204 response"
                }
                call log_tx $logctl req_result "MSDK-config-update failed, ${I1_Status}" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}] benign false
                HTTP::respond 204 -version auto noserver Cache-Control no-cache Connection close
            }
            return
        }

        # setting flag for javascript injection exclusion
        if {[set "${sI1me}js_inject_incl"]} {
            set I1_js_inj_excluded 1
            foreach {row} [set "${sI1me}JS_INCL"] {
                foreach {prex qrex} $row { break }
                if {[regexp $prex $I1_norm_path] &&
                        (($qrex eq "") || [regexp $qrex $I1_exp_qry])} {
                    set I1_js_inj_excluded 0
                }
            }
        }
        if {[set "${sI1me}js_inject_excl"]} {
            foreach {row} [set "${sI1me}JS_EXCL"] {
                foreach {prex qrex} $row { break }
                if {[regexp $prex $I1_norm_path] &&
                        (($qrex eq "") || [regexp $qrex $I1_exp_qry])} {
                    set I1_js_inj_excluded 1
                }
            }
        }
    }

    if {[regexp {^(GET|HEAD)$} $I1_http_method] &&
                ([set tmp [HTTP::header ISTL-Referer]] ne "")} {
        HTTP::header remove Referer
        HTTP::header remove ISTL-Referer
        HTTP::header insert Referer $tmp
    }

    if {[regexp {(^|[^\w])[bB][rR]([^\w]|$)} [HTTP::header Accept-Encoding]]} {
        HTTP::header remove Accept-Encoding
        HTTP::header insert Accept-Encoding "gzip, deflate"
    }

    set I1_xff [getfield [lindex [split [HTTP::header X-Forwarded-For] ","] 0] % 1]

    if {(![set "${sI1me}kill_switch"]) &&
        ($I1_http_method eq "GET") &&
        ( ($I1_norm_path eq [set "${sI1me}js_inj_path"]) ||
          ("${I1_http_hostname}${I1_norm_path}" eq [set "${sI1me}js_inj_path"]) )} {

        set I1_req_type 1

        # -- we don't want AGP iApp to process ibd JS request
        set shp_global_request_ibd_processed 1

        if {[HTTP::uri] ends_with "?matcher"} {
            if {$v_debug} {
               call xlog $logctl debug "Matcher JS requested, method: ${I1_http_method}, uri: [HTTP::uri]"
            }
            set tmp [set "${sI1me}sl_matchers"]
            call log_tx $logctl req_result "reply matcher-JS, [string length $tmp] octets" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
            HTTP::respond 200 -version auto content $tmp noserver Cache-Control "no-cache" Content-Type "application/javascript"
        } else {
            # route request for F5 Client JS to API server
            set I1_sent_to_API 1

            set I1_msdk_req 0 ; #not an MSDK endpoint

            call insert_ibd_headers $I1_xff $I1_msdk_req $I1_fp $I1_tls_fp $I1_req_type $I1_istl_endpt $I1_action $v_debug $logctl

            if {$v_debug} {
                call xlog $logctl debug "send Client JS request to API server"
            }
            set I1_Payload ""
            set I1_Request [HTTP::request]

            set I1_Status [call ibd_api_call $I1_Request $I1_Payload $I1_req_type $I1_msdk_req $v_debug $logctl]

            if {$I1_Status == 999} {
                #handle 'direct' in HTTP_RESPONSE
                set I1_direct_op "client JS fetch"
                return
            }

            set txdata(inference) $I1_Inference
            set txdata(atmn_type) $I1_Reason

            # If status is 200, respond to client with F5 Client JS
            if {$I1_Status equals "200"} {
                set resBody "I1_ResBody"
                call log_tx $logctl req_result "reply F5 Client JS, [string length $I1_ResBody] octets" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
                eval "HTTP::respond 200 -version auto content $$resBody noserver $I1_ResHeaders"
            } else {
                # Since the API Response is not a 200, send back an empty 200 OK
                if {$v_debug} {
                    call xlog $logctl debug "[IP::client_addr]:[TCP::client_port]: Client JS download failed status $I1_Status Sent 204 response"
                }
                call log_tx $logctl req_result "F5 Client-JS failed, ${I1_Status}" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}] benign false
                HTTP::respond 204 -version auto noserver Cache-Control "no-cache" Connection "close"
            }
        }
        return
    }

    # may client skip inspection?
    if {( ([set "${sI1me}kill_switch"] || $I1_METHOPT) &&
          ([set I1_byp "bypassed"] ne "") ) ||
        ( [call get_f5xcc_allow $I1_xff [IP::client_addr] $v_debug $logctl] &&
          ([set I1_byp "allowed"] ne "") )} {

        # will send request to origin below

        if {$v_debug} {
            call xlog $logctl debug "this request to be ${I1_byp} to origin"
        }

        set I1_protection [list]
    } else {
        set I1_protection [call get_mitigation_action $I1_http_method $I1_http_hostname $I1_norm_path $I1_exp_qry $v_debug $logctl]
    }

    # [get_mitigation_action] returns empty-list if not prot-endpt,
    # else {PROTECTED/ISTL {0/1/2/3 ACTION}}
    # if endpoint-type 2/3 we check body for msdk match

    set I1_ept ""
    foreach {I1_ept I1_action} [lindex $I1_protection 1] { break }

    # may collect POST/PUT/whatever bodies either to check/
    # send to some API server or to cleanse of telemetry, so...
    #
    #TODO: deal with chunked-transfer-encoding (may not be simple)
    #
    set I1_data_capture false
    if {([set content_length [HTTP::header Content-Length]] eq "") ||
                                                    ($content_length == 0)} {
        #cannot find MSDK ID in non-existent body
        if {$I1_ept == 2} {
            #now we know isn't msdk (or any other kind of) endpoint
            set I1_ept ""
            set I1_protection [list]
        } elseif {$I1_ept == 3} {
            #is web endpoint, not msdk
            lset I1_protection {1 0} [set I1_ept 0]
        }
    } else {
        if {(($I1_ept ne "") && ($I1_ept > 1)) ||
                ($I1_http_ctype eq "application/x-www-form-urlencoded")} {

            if {$content_length > 1048568} { set content_length 1048568 }
            HTTP::collect $content_length
            set I1_data_capture true
        }
    }
    unset -nocomplain content_length

    if {![llength $I1_protection]} {
        # Non-protected endpoint or allow or bypass
        # send request to origin
        set I1_req_type 0

        return
    } else {
        # req is likely a Protected Endpoint; try to send to API
        set I1_req_type 2

        if {($I1_ept ne "") && ($I1_ept > 1)} {
            #need to see if body matches msdk endpoint
            set I1_protect_pending_body $I1_protection
        } elseif {([lindex $I1_protection 0] eq "ISTL") &&
                                ($I1_http_method eq "GET")} {
            set I1_istl_endpt true
        }
        if {$v_debug} {
            call xlog $logctl debug "ISTL protected endpoint= $I1_istl_endpt"
        }

        # Ready to route to API
        # --- we don't want APG iApp to process protected endpoint when it is routed to API
        set shp_global_request_ibd_processed 1

        set I1_sent_to_API 1

        if {!$I1_data_capture} {
            # Mostly Http GET method, such as ISTL protected endpoint
            if {[set mitigation [lindex [lindex $I1_protection 1] 1]] eq ""} {
                #should not get here
                set mitigation "continue"
            }

            set I1_msdk_req 0 ; #default to web API server

            if {$I1_istl_endpt} {
                set I1_req_type 3
            } elseif {($I1_ept ne "") && ($I1_ept > 0)} {
                if {($mitigation eq "drop") || ($mitigation eq "redirect")} {
                    set mitigation "block"
                }
                set I1_msdk_req 1 ; #call MSDK API server
            }

            set txdata(mitigation) "[lindex $I1_protection 0] ${mitigation}"

            call insert_ibd_headers $I1_xff $I1_msdk_req $I1_fp $I1_tls_fp $I1_req_type $I1_istl_endpt $I1_action $v_debug $logctl
            set I1_Payload ""
            set restore_clen [HTTP::header Content-Length]
            HTTP::header replace Content-Length 0

            set I1_Request [HTTP::request]
            set f5xcc_cookie [call f5xcc_mitigation_decision $mitigation $I1_Request $I1_Payload $I1_req_type $I1_msdk_req $v_debug $logctl]

            if {![HTTP::has_responded]} {
                HTTP::header remove Content-Length
                if {$restore_clen ne ""} {
                    HTTP::header replace Content-Length $restore_clen
                }
                call remove_ibd_headers $v_debug $logctl
            }
            unset -nocomplain restore_clen

            if {[string tolower $f5xcc_cookie] eq "interstitial served"} {
                return
            }
            if {$I1_istl_endpt} {
                set I1_req_type 2
            }
            if {$f5xcc_cookie ne "" && $f5xcc_cookie ne "no_cookie"} {
                set I1_f5xcc_cookie $f5xcc_cookie
            }
        }
        return
    }
} ; #HTTP_REQUEST


when HTTP_REQUEST_RELEASE {
    call remove_telem_headers $v_debug $logctl
    # Remove telemetry from body in HTTP_REQUEST_DATA
} ; #HTTP_REQUEST_RELEASE


when HTTP_REQUEST_DATA {
    if {!$I1_f5xcc_working} {
        return ; # customer iRule preempted us
    }

    # save payload to send to API server or scrub of telemetry
    binary scan [HTTP::payload] a* I1_http_payload

    if {$v_debug} {
        call xlog $logctl debug "REQ_DATA Got [string length $I1_http_payload] chars"
    }

    set I1_msdk_req 0
    if {[string length $I1_http_payload] && [llength $I1_protect_pending_body]} {
        set I1_sent_to_API 1
        set tmp {__MSDK_BODY_REGEX__}
        #following regexp may bogusly-transcode body data
        if {($tmp ne {}) && [regexp $tmp $I1_http_payload]} {
            if {$v_debug} {
                call xlog $logctl debug "REQ_DATA Request matches MSDK endpoint body-test, send to MSDK API"
            }
            set tmp [lindex [lindex $I1_protect_pending_body 1] 1]
            if {($tmp eq "redirect") || ($tmp eq "drop")} {
                lset I1_protect_pending_body {1 1} "block"
            }
            set I1_msdk_req 1
        } else {
            # not msdk, but perhaps web protected-endpoint?
            if {[lindex [lindex $I1_protect_pending_body 1] 0] < 3} {
                #oops, not web protected either
                if {$v_debug} {
                    call xlog $logctl debug "REQ_DATA Did not match MSDK endpoint body-test, bypass this request"
                }
                set I1_protect_pending_body [list]
                set I1_sent_to_API 0
            } else {
                if {$v_debug} {
                    call xlog $logctl debug "REQ_DATA Did not match MSDK endpoint body-test, fallback to web protected-endpoint"
                }
                lset I1_protect_pending_body {1 0} 0
            }
        }

        set I1_protection $I1_protect_pending_body
    } elseif {($I1_ept ne "") && ($I1_ept > 0)} {
        set tmp [lindex [lindex $I1_protection 1] 1]
        if {($tmp eq "redirect") || ($tmp eq "drop")} {
            lset I1_protection {1 1} "block"
        }
        set I1_msdk_req 1 ; #call MSDK API server
    }

    if {$I1_sent_to_API == 0} {
        if {$v_debug} {
            call xlog $logctl debug "REQ_DATA Bypass/allow request"
        }
        # will deal with telemetry below
    } elseif {$I1_sent_to_API < 3} {
        #TODO: why < 3 ??

        # filter body data before sending to API server
        set I1_Payload [call filter_customer_payload $I1_http_payload $I1_http_ctype $v_debug $logctl]
        set orig_clen [HTTP::header Content-Length]
        HTTP::header replace Content-Length [string length $I1_Payload]

        call insert_ibd_headers $I1_xff $I1_msdk_req $I1_fp $I1_tls_fp $I1_req_type $I1_istl_endpt $I1_action $v_debug $logctl

        if {[set mitigation [lindex [lindex $I1_protection 1] 1]] eq ""} {
            #should not get here
            set mitigation "continue"
        }
        set txdata(mitigation) "[lindex $I1_protection 0] ${mitigation}"

        set I1_Request [HTTP::request]
        set f5xcc_cookie [call f5xcc_mitigation_decision $mitigation $I1_Request $I1_Payload $I1_req_type $I1_msdk_req $v_debug $logctl]

        # retain cookie if any from POST telemetry API call
        if {($f5xcc_cookie ne "") && ($f5xcc_cookie ne "no_cookie")} {
            set I1_f5xcc_cookie $f5xcc_cookie
        }

        if {![HTTP::has_responded]} {
            HTTP::header replace "Content-Length" $orig_clen
            call remove_ibd_headers $v_debug $logctl
        }
        unset orig_clen
    } else {
        # We should not come here
        call xlog $logctl debug "Unk \x24I1_sent_to_API value ${I1_sent_to_API}"
    }

    # try to clean out telemetry
    call remove_telem_payload $I1_http_payload $I1_http_ctype $v_debug $logctl
} ; #HTTP_REQUEST_DATA

when HTTP_RESPONSE {
    set nonce 1
    if {[HTTP::header exists "Content-Security-Policy"]} {
	    set nonce [findstr [HTTP::header Content-Security-Policy] \'nonce 7 \']
    } elseif {[HTTP::header exists "Content-Security-Policy-Report-Only"]} {
        set nonce [findstr [HTTP::header Content-Security-Policy-Report-Only] \'nonce 7 \']
    } else {
    return
    }
    if {!$I1_f5xcc_working} {
        return ; # customer iRule preempted us
    }

    set resp_ctype [string tolower [HTTP::header Content-Type]]
    if {$v_debug} {
        call xlog $logctl debug "Response HTTP path '${I1_norm_path}', content-type = ${resp_ctype}, encoding= [HTTP::header Content-Encoding]"
    }
    if {$resp_ctype contains "javascript"} {
        if {$v_debug} {
            call xlog $logctl debug "Disable decompression of JS response"
        }
        # DECOMPRESS::disable supported only when virtual server
        # has attached HTTP Compression Profile
        catch { eval { [join [list "DECOM" "PRESS::disable"] ""] } }
    }

    if {[set tmp [HTTP::header x-ibd-api-info]] ne ""} {
        set txdata(api_info) $tmp
    }
    unset tmp
    HTTP::header remove x-ibd-api-info

    if {$I1_direct} {
        set I1_Status [HTTP::status]

        set txdata(atmn_type) [HTTP::header automation_type]
        HTTP::header remove automation_type

        HTTP::header insert Connection close

        if {$I1_Status == 200} {
            set txdata(inference) [HTTP::header inference]
            HTTP::header remove inference

            set tmp [HTTP::header Content-Length]
            set tmp [expr {($tmp ne "") ? ", ${tmp} octets" : ""}]
            call log_tx $logctl req_result "reply ${I1_direct_op}${tmp}" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]
            unset tmp
        } else {
            # if API Response is not 200, send back 204 No Content
            if {$v_debug} {
                call xlog $logctl debug "${I1_direct_op} failed, API status $I1_Status Sent 204 response"
            }
            set txdata(inference) "none, API call failed"
            call log_tx $logctl req_result "${I1_direct_op} failed, ${I1_Status}" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}] benign false
            HTTP::respond 204 -version auto noserver Cache-Control no-cache Connection close
        }
        return
    }

    if {![info exists txdata(inference)]} {
        set txdata(inference) "No Inference NA"
    }

    if {$v_debug} {
        call xlog $logctl debug "HTTP_RESPONSE --- sent_to_API: $I1_sent_to_API req_type: $I1_req_type status [HTTP::status]"
    }

    if {$I1_req_type == 0} {
        set txdata(inference) "No Inference NA"
    }

    # F5 Client JS using SIDEBAND (only) won't fire HTTP_RESPONSE
    # Other cases are for response from origin server
    if {$v_debug}{
        call xlog $logctl debug "HTTP_RESPONSE from origin"
    }

    # add cookie to response if given, except special value "no_cookie"
    if {$I1_f5xcc_cookie ne "" && $I1_f5xcc_cookie ne "no_cookie"} {
        HTTP::header insert "Set-Cookie" $I1_f5xcc_cookie
        if {$v_debug}{
            call xlog $logctl debug "Sent to client F5XC cookie $I1_f5xcc_cookie"
        }
    }

    set tmp [expr {($txdata(inference) eq "malicious") ?
                            "continue but flag,\x20" : ""}]
    call log_tx $logctl req_result "${tmp}request ${I1_byp}, origin status [HTTP::status]" tcp_rtt:n [expr {round([TCP::rtt]/32.0+0.5)}]

    return
} ; #HTTP_RESPONSE

__HTML_TAG_MATCHED__

when CLIENT_CLOSED {
    if {$v_debug} {
        call xlog $logctl debug "CLIENT_CLOSED [IP::client_addr]_[TCP::client_port]"
    }
    if {!$txdata(done)} {
        if {![catch {TCP::rtt} tmp]} {
            set txdata(tcp_rtt:n) [expr {round($tmp/32.0+0.5)}]
        }
        call log_tx $logctl req_result "connection interrupted"
    }
} ; #CLIENT_CLOSED

} ; #::f5xcc_sed_irule

set ::htm_evt {
when HTML_TAG_MATCHED {
    if {!$I1_f5xcc_working} {
        return ; # customer iRule preempted us
    }

    # due to an issue in TMOS v16.0.1 and lower,
    # we cannot 'call xlog ...' from this event
    set dpri "[set "${sI1me}log_fac"].debug"

    if {$v_debug} {
        log $dpri "HTML_TAG_MATCHED --- [HTML::tag name]"
    }

    if {[set "${sI1me}kill_switch"]} {
        if {$v_debug} {
            log $dpri "no JS injection, kill switch"
        }
        return
    }
    if {not [set "${sI1me}do_js_injection"]} {
        if {$v_debug} {
            log $dpri "no JS injection, not enabled"
        }
        return
    }
    if {$I1_js_inj_excluded} {
        if {$v_debug} {
            log $dpri "no JS injection, path excluded"
        }
        return
    }
    if {$I1_js_inj_io_done && $I1_js_inj_tel_done} {
        if {$v_debug} {
            log $dpri "JS injection already done"
        }
        return
    }

    #JS injection settings
    set I1_js_telem_in_body {__JS_INJ_TEL_IN_BODY__}
    set I1_js_io_snippet {__JS_INJ_IO__}
    set I1_js_tel_snippet {__JS_INJ_TEL__}

    if {!$I1_js_inj_io_done &&
        ([string tolower [HTML::tag name]] eq "__JS_INJ_TAG__")} {
        if {$v_debug} {
            log $dpri "injecting matcher&cache JS"
        }
           if {$nonce != 1} {
            set map_find "<script"
            set map_replace "<script nonce=$nonce"
            regsub -nocase -all $map_find "${I1_js_io_snippet}" $map_replace js_snippet
        } else {
            set js_snippet $I1_js_io_snippet
        }
        if {!$I1_js_telem_in_body} {
            if {$v_debug} {
                log $dpri "injecting async JS together"
            }
            if {$nonce != 1} {
                regsub -nocase -all $map_find "${I1_js_io_snippet}${I1_js_tel_snippet}" $map_replace js_snippet
            } else {
                set js_snippet ${I1_js_io_snippet}${I1_js_tel_snippet}
            }
        }

        if {__JS_INJ_POSITION__ == 0} {
            HTML::tag append $js_snippet
        } else {
            HTML::tag prepend $js_snippet
        }
        set I1_js_inj_io_done 1
        if {!$I1_js_telem_in_body} {
            set I1_js_inj_tel_done 1
        }
    }
    if {$I1_js_telem_in_body &&
            not $I1_js_inj_tel_done &&
            ([string tolower [HTML::tag name]] eq "body")} {
        if {$v_debug} {
            log $dpri "injecting async JS separately"
        }
        HTML::tag append ${I1_js_tel_snippet}
        set I1_js_inj_tel_done 1
    }
    unset nonce
} ; #HTML_TAG_MATCHED
} ; #::htm_evt
######## XC Security API server iRule END ########
# IAPP
proc tmsh_create { component arguments } {
    regsub -all {\"} $arguments "\\\"" arguments
    regsub -all {\[} $arguments "\\\[" arguments
    regsub -all {\]} $arguments "\\\]" arguments
    tmsh::run_proc f5.app_utils:do_tmsh_create "\"$component\"" "\"$arguments\""
}

proc tmsh_modify { component arguments } {
    regsub -all {\"} $arguments "\\\"" arguments
    regsub -all {\[} $arguments "\\\[" arguments
    regsub -all {\]} $arguments "\\\]" arguments
    tmsh::run_proc f5.app_utils:do_tmsh_modify "\"$component\"" "\"$arguments\""
}

# Search on given vs for profile from given type
proc find_profile {vs_obj type sub_type} {
    set found false
    set fomated_type $type

    if { $type eq "profile" } {set fomated_type "profiles"}

    catch {
        foreach {profile} [tmsh::get_config /ltm $type $sub_type] {
            foreach {vs_profile} [tmsh::get_field_value $vs_obj $fomated_type] {
                if {[lindex $vs_profile 1] eq [lindex $profile 3]} {
                    set found true
                    return [lindex $vs_profile 1]
                }
            }
        }
    } result
    if { $found } {
        return $result
    }
    return ""
}


# indicate whether feature is in licensed active list
proc have_license {feature} {
    return [expr {[lsearch -exact $::bigip_licensed $feature] >= 0}]
} ; #have_license

#
# iCall script for FQDN pool maintenance
#
# We need this because TMOS can only maintain
# FQDN pools in route-domain zero.  However,
# this scheme may cause the config-update flag
# to be set often.  The changes are small so
# auto-config-sync can handle them, or you can
# just use manual config-sync and try not to
# let the out-of-sync warning bother you when
# you have not deliberately updated the config
#
set ::fqdn_scr {
 set me "${EVENT::script_name} (@@MYAPP@@):"
 if {[llength [set tgt $EVENT::context(target)]] != 7} {
  set e "${me} invalid event-context var 'target'='${tgt}'"
  catch {exec /bin/logger -p local0.err $e}
  return -code error $e
 }
 foreach {debug ripe tg pool fqdn rd port} $tgt { break }

 if {[catch {tmsh::show "/ cm failover-status"} sts]} {
  set e "${me} show cm failover-status failed: '${sts}'"
  catch {exec /bin/logger -p local0.err $e}
  return -code error $e
 }
 set standby true
 foreach {junk active} [regexp -all -inline {active for ([^ \n]+)} $sts] {
  if {$tg eq $active} { set standby false }
 }
 if {$standby} {
  if {$debug} {
   if {[catch {lindex [tmsh::get_config "/ cm device hostname"] [list 0 3 1]} h]} {
    set e "${me} list cm device hostname failed: '${h}'"
    catch {exec /bin/logger -p local0.err $e}
    return -code error $e
   }
   set d "${me} will NOT update pool '${pool}' on this device '${h}' because it is not active for traffic-group ${tg}"
   catch {exec /bin/logger -p local0.debug $d}
  }

  return -code ok
 }

 if {[catch {lindex [tmsh::get_config "/ ltm pool ${pool} description"] [list 0 3 1]} tmp] ||
     ([llength $tmp] != 3) ||
     ([set prev [expr {[catch {clock scan [lindex $tmp 2]} tmp] ? -1 : $tmp}]] < 0)} {
  set e "${me} get last update time for pool '${pool}' failed: '${tmp}' (may be iApp reconfiguration in progress)"
  catch {exec /bin/logger -p local0.err $e}
  return -code error $e
 }
 set now [clock format [clock seconds] -format "%Y%m%dT%H%M%SZ" -gmt true]
 if {[catch {expr {[clock scan $now] - $prev}} age]} { set age 308 }

 if {[catch {tmsh::show "/ ltm pool ${pool} field-fmt all-properties"} tmp] ||
     ![regexp {active-member-cnt ([0-9]+)} $tmp junk mc]} {
  set e "${me} get active-member count for pool '${pool}' failed: '${tmp}'"
  catch {exec /bin/logger -p local0.err $e}
  return -code error $e
 }

 set young [expr {$ripe ? ($age < $ripe) : 1}]
 set cruise [expr {$young && $mc}]
 if {$debug} {
  set d "${me} pool '${pool}' has ${mc} active members.\x20"
  append d "Age ${age} is [expr {$young ? "less" : "more"}] than ripe-age [expr {$ripe ? $ripe : "max-possible"}], so\x20"
  append d [expr {$cruise ? "leave pool alone" : "try to update members"}]
  catch {exec /bin/logger -p local0.debug $d}
 }
 if {$cruise} {
  return -code ok
 }

 if {[catch {exec /bin/nslookup $fqdn} rslt] &&
     ![regexp {FIPS mode or MD5} $rslt]} {
  set e "${me} nslookup fqdn '${fqdn}' failed: '[regsub -all {[ \t\n]+} $rslt "\x20"]'"
  catch {exec /bin/logger -p local0.err $e}
  return -code error $e
 }
 set members [list]
 foreach {line} [split $rslt "\n"] {
  if {[regexp {^Address:[ ]+([0-9.]+)$} $line junk ip]} {
   lappend members "${ip}%${rd}:${port}"
  }
 }
 if {![llength $members]} {
  set e "${me} unable to update ${mc}-member[expr {$young ? "" : "\x20overripe"}] pool '${pool}' because no A records found for fqdn '${fqdn}'"
  catch {exec /bin/logger -p local0.err $e}
  return -code error $e
 }

 if {$debug} {
  set d "${me} will update pool '${pool}' for traffic-group '${tg}' with nslookup '${fqdn}' results {${members}}"
  catch {exec /bin/logger -p local0.debug $d}
 }
 if {[catch { tmsh::begin_transaction ; \
              tmsh::modify "/ ltm pool ${pool} description 'last update ${now}' members replace-all-with { [join $members] }" ; \
              tmsh::commit_transaction } err]} {
  set e "${me} modifying members of pool '${pool}' failed: '${err}'"
  catch {exec /bin/logger -p local0.err $e}
  return -code error $e
 }

 return -code ok
 #end of script
} ; #::fqdn_scr

# make a pool:
#    if 'fqdn' is actually a static IP, just add it
#    (not used much).
#    For domain names, in Common/RD0-only-mode use
#    LTM fqdn-member (ephemeral nodes) mechanism,
#    but for any other combo use an iCall script to
#    resolve domain to IP's and add those as pool members
#
# scr_debug = enable iCall debugging (perforce to local log only)
# ripe = interval between forced updates of IP's for FQDN
# tg = traffic group for virtuals using pool
# usage = string like "web" or "msdk"
# fqdn = server fqdn (possibly a single IP)
# rd = route domain for pool members
# port = TCP port for pool members
# name_pfx = path-prefix for component names
# aso_own = true if ASO should own components
# is_api_svr = if true use API service monitor
#
proc make_a_pool {scr_debug ripe tg usage fqdn rd port name_pfx is_api_svr} {
    set poolname "${name_pfx}${usage}"

    set now [clock format [expr {[clock seconds] - 900}] -format "%Y%m%dT%H%M%SZ" -gmt true]

    foreach {dessert} [list web msdk proxy2api] {
        if {$usage eq $dessert} { continue }
        if {([set tmp [load "${usage}_pool"]] ne "") &&
                ($tmp ne $poolname)} {
            iapp::conf "delete / ltm pool '${tmp}'"
            store "${usage}_pool" ""
        }
        if {([set tmp [load "${usage}_mon"]] ne "") &&
                ($tmp ne $poolname)} {
            iapp::conf "delete / ltm monitor tcp '${tmp}'"
            store "${usage}_mon" ""
        }
    }

    set monitor ""
    if {$is_api_svr && $::api_mon_http && ($::pool__check eq "Yes")} {
        lnew c "create / ltm monitor tcp '${poolname}'"
        if {!$::api_svr_aso} {
            lappend c "app-service none"
            store "${usage}_mon" $poolname
        }
        lappend c "destination '*:${::pool__port}'"
        lappend c "send 'GET ${::pool__url} HTTP/1.1\\r\\nHost: ${fqdn}\\r\\nConnection:\\ close\\r\\n\\r\\n'"
        lappend c "recv '${::pool__rc}'"
        lappend c "description 'updated ${now}'"
        iapp::conf [join $c]

        set monitor $poolname
    }

    set lb_mode [expr {[have_license ltm_lb_predictive] ? "predictive-member" : "round-robin"}]

    lnew c "create / ltm pool '${poolname}'"
    if {!$::api_svr_aso} {
        lappend c "app-service none"
        store "${usage}_pool" $poolname
    }
    set inband_okay [have_license ltm_monitor_inband]
    set psep ""
    if {[regexp {(?:i)(^([0-9]{1,3}[.]){3}[0-9]{1,3}$)|:} $fqdn]} {
        #fixed IP (only IPv6 has colon)
        set psep [expr {([string first ":" $fqdn] > 0) ? "." : ":"}]
        lappend c "members replace-all-with { '${fqdn}%${rd}${psep}${port}' }"
        lappend c "description 'updated ${now}'"
    } elseif {$::api_pool_fqdn} {
        set inband_okay false ; # sadly no monitor-inband with FQDN nodes

        set psep ":"
        set tmp "/Common/${fqdn}${psep}${port}"
        lappend c "members replace-all-with \x7b"
         lappend c "'${tmp}' \x7b"
          if {!$::api_svr_aso} {
            lappend c "app-service none"
            store "{usage}_fqdn" $fqdn
          }
          lappend c "fqdn { name '${fqdn}' autopopulate enabled }"
         lappend c "\x7d"
        lappend c "\x7d"
        lappend c "description 'updated ${now}'"
    } else {
        lappend c "members none"
        lappend c "description 'last update ${now}'"
    }
    lappend c "load-balancing-mode ${lb_mode}"
    if {$monitor ne ""} {
        lappend c "monitor '${monitor}'"
    } else {
        if {$inband_okay} {
            lappend c "monitor inband"
        } else {
            lappend c "monitor tcp_half_open"
        }
    }
    iapp::conf [join $c]

    if {$psep ne ""} {
        # fixed IP or FQDN in RD0 means we're done early
        return $poolname
    }
    #otherwise

    # set up iCall to maintain FQDN pool

    # iCall script will belong to ASO

    if {![info exists ::fqdn_script_name] || ($::fqdn_script_name eq "")} {
        set ::fqdn_script_name "${::iapp_prefix}fqdn-script"

        regsub {@@MYAPP@@} $::fqdn_scr $::myapp patched

        lnew c "create sys icall script '${::fqdn_script_name}'"
        lappend c "description 'Maintains F5XCC FQDN pools [clock seconds]_[clock clicks]'"
        lappend c "definition { ${patched} }"
        iapp::conf [join $c]
    }

    set handlername "${::iapp_prefix}${usage}-handler"

    lnew c "create sys icall handler periodic '${handlername}'"
    lappend c "arguments \x7b"
     lappend c "\x7b name target"
      lappend c "value '[list $scr_debug $ripe $tg $poolname $fqdn $rd $port]'"
     lappend c "\x7d"
    lappend c "\x7d"
    lappend c "interval 307"
    lappend c "script '${::fqdn_script_name}'"
    lappend c "status active"
    lappend c "description 'Maintains F5XCC FQDN pools [clock seconds]_[clock clicks]'"
    iapp::conf [join $c]
    store "${usage}_handler" $handlername

    return $poolname
} ; #make_a_pool


proc make_api_snatpool {} {
    set ips [list]
    foreach {member} $::api__snats {
        set ip [tmsh::get_field_value $member ip]
        if {[string first "%" $ip] < 0} {
            append ip "%" $::api_svr_rd
        }
        lappend ips $ip
    }
    if {![llength $ips]} {
     return 0
    }

    tmsh_create "/ ltm snatpool" "${::api_snatpool_name} members replace-all-with { [join $ips "\x20"] }"
    return 1
} ; #make_api_snatpool

proc make_web_vs {snat} {
    set serverssl_profile $::api__serverssl
    set web_vs_port 443

    if {$::api__proxy eq "Yes"} {
        set web_vs_pool $::f5xcc_proxy_pool_name
    } else {
        set web_vs_pool $::f5xcc_web_pool_name
    }

    # Create http profile
    tmsh_create "/ ltm profile http" "${::helper_http_profile} defaults-from http response-chunking unchunk"

    # Create oneconnect profile for helper virtual-server
    tmsh_create "/ ltm profile one-connect" "${::helper_one_connect} defaults-from /Common/oneconnect max-size 500 max-age 1800"

    # (optionally) Create http proxy connect profile
    if {$::api__proxy eq "Yes"} {
        tmsh_create "/ ltm profile http-proxy-connect" "${::helper_proxy_profile} defaults-from http-proxy-connect"
    }

    # create web vs

    lnew c "create / ltm virtual '${::f5xcc_web_vs_name}'"
    lappend c "destination ${::api_vs_ip}:${web_vs_port}"
    lappend c "profiles replace-all-with \x7b"
     lappend c "${::helper_http_profile}"
     lappend c "${::helper_one_connect} { context all }"
     lappend c "${serverssl_profile} { context serverside }"
     if {$::api__proxy eq "Yes"} {
       lappend c "${::helper_proxy_profile}"
     }
    lappend c "\x7d"
    lappend c "pool ${web_vs_pool}"
    if {$snat eq "automap"} {
     lappend c "source-address-translation { type automap }"
    } else {
     lappend c "source-address-translation { type snat pool '${snat}' }"
    }
    lappend c "rules { ${::sband_helper_irule_name} }"
    lappend c "description 'F5 XCC Web API'"
    iapp::conf [join $c]
} ; #make_web_vs

proc make_msdk_vs {snat} {
    set serverssl_profile $::api__serverssl
    set msdk_vs_port 444

    if {$::api__proxy eq "Yes"} {
        set msdk_vs_pool $::f5xcc_proxy_pool_name
    } else {
        set msdk_vs_pool $::f5xcc_msdk_pool_name
    }

    # create msdk vs

    lnew c "create / ltm virtual '${::f5xcc_msdk_vs_name}'"
    lappend c "destination ${::api_vs_ip}:${msdk_vs_port}"
    lappend c "profiles replace-all-with \x7b"
     lappend c "${::helper_http_profile}"
     lappend c "${::helper_one_connect} { context all }"
     lappend c "${serverssl_profile} { context serverside }"
     if {$::api__proxy eq "Yes"} {
       lappend c "${::helper_proxy_profile}"
     }
    lappend c "\x7d"
    lappend c "pool ${msdk_vs_pool}"
    if {$snat eq "automap"} {
     lappend c "source-address-translation { type automap }"
    } else {
     lappend c "source-address-translation { pool ${snat} }"
    }
    lappend c "rules { ${::sband_helper_irule_name} }"
    lappend c "description 'F5 XCC MSDK API'"
    iapp::conf [join $c]
} ; #make_msdk_vs


proc detach_html_rules {} {
    # html_profile does not exist until first deployment is completed
    set html_profiles [tmsh::get_config /ltm profile html]
    foreach {html_profile} $html_profiles {
        set html_profile_name [lindex $html_profile 3]
        catch { tmsh_modify "/ ltm profile" "html ${html_profile_name} rules delete { $::html_js_rule_name }" }
        catch { tmsh_modify "/ ltm profile" "html ${html_profile_name} rules delete { $::html_iojs_rule_name }" }
    }
}

set ::web_api_fqdn "ibd-webemea2.fastcache.net"
set ::msdk_api_fqdn "ibd-mobileemea2.fastcache.net"

proc get_api_params {} {
    if {[string first "\x25\x25\x25" $::web_api_fqdn] == 0} {
        set ::web_api_fqdn [expr {[info exists ::api__cluster_fqdn] ?
                                  $::api__cluster_fqdn : ""}]
    }
    if {[string first "\x25\x25\x25" $::msdk_api_fqdn] == 0} {
        set ::msdk_api_fqdn [expr {($::do_msdk && [info exists ::api__msdk_api_fqdn]) ?
                                   $::api__msdk_api_fqdn : ""}]
    }

    if {[info exists ::init__noPartns] &&
                $::init__noPartns && ($::mypartn eq "Common")} {
        # customer promises to use only /Common+RD0
        set ::api_svr_rd $::myRD
        set ::api_svr_aso true
        set ::api_pool_fqdn true
        set ::api_mon_http true
        set ::myRDPrefix $::iapp_prefix
        set ::api_svr_ripe 86400
    } else {
        set tmp [expr {[info exists ::api__rd] ? $::api__rd : $::myRD}]
        if {$tmp eq "/#0#"} {
            set tmp 0
        } elseif {$tmp eq "/#dfl#"} {
            set tmp $::myRD
        }
        set ::api_svr_rd $tmp

        set rd_partn [rd_partition $::api_svr_rd]

        # gonna use icall-script-maintained pool
        set ::api_pool_fqdn false
        set ::api_svr_aso false

        set ::api_mon_http false

        if {($::mypartn eq "Common") && ($::api_svr_rd == 0)} {
            set ::myRDPrefix $::iapp_prefix
            set ::api_mon_http true
        } elseif {$::mypartn eq $rd_partn} {
            set ::myRDPrefix $::iapp_prefix
            set ::api_mon_http true
        } elseif {$rd_partn eq "Common"} {
            set ::myRDPrefix $::myCommonPrefix
        } else {
            # we are stymied
            fail "Cannot use route-domain ${::api_svr_rd} to reach F5 API servers because it belongs to partition ${rd_partn} rather than the partition for this Application Service ${::mypartn}."
        }

        set tmp [expr {[info exists ::api__ripe] ? $::api__ripe : 0}]
        set ::api_svr_ripe [expr {$tmp * 3600}]
    }

    #turns out we must use the iApp's traffic-group,
    #which user can change in "Template Selection: Advanced"
    #when (re-)configuring ASO.  (Or we could get seriously
    #brutal on the config but I don't want to go there.)
    #
    set ::api_svr_tg $::myTG
} ; #get_api_params

proc config_web_api_pool {} {
    if {![info exists ::web_api_fqdn] || ($::web_api_fqdn eq "")} {
        fail "Hostname of Defense Engine web API server not configured"
    }

    ### proc- make_a_pool {scr_debug ripe tg usage fqdn rd port name_pfx is_api_svr}
    set ::f5xcc_web_pool_name [make_a_pool $::runtime_debug $::api_svr_ripe $::api_svr_tg "web" $::web_api_fqdn $::api_svr_rd 443 $::myRDPrefix true]
} ; #config_web_api_pool

proc config_msdk_api_pool {} {
    if {![info exists ::msdk_api_fqdn] || ($::msdk_api_fqdn eq "")} {
        fail "Hostname of Defense Engine MSDK API server not configured"
    }

    ### proc- make_a_pool {scr_debug ripe tg usage fqdn rd port name_pfx is_api_svr}
    set ::f5xcc_msdk_pool_name [make_a_pool $::runtime_debug $::api_svr_ripe $::api_svr_tg "msdk" $::msdk_api_fqdn $::api_svr_rd 443 $::myRDPrefix true]
} ; #config_msdk_api_pool

proc config_proxy_pool {} {
    if {![info exists ::api__proxy_pool_source]} {
        fail "Missing proxy_pool_source!"
    }
    if {$::api__proxy_pool_source eq "Use Existing"} {
        if {![info exists ::api__proxy_pool_existing] ||
                ([set ::f5xcc_proxy_pool_name $::api__proxy_pool_existing] eq "")} {
            fail "You must supply an existing proxy pool"
        }
        return
    }

    if {$::api__proxy_pool_source eq "FQDN"} {
        set h [string trim $::api__proxy_pool_fqdn__fqdn]
        set p [string trim $::api__proxy_pool_fqdn__port]

        if {([string first ":" $h] >= 0) ||
                    [regexp {^([0-9]{1,3}[.]){3}[0-9]{1,3}$} $h]} {
            fail "Cannot use IP address as FQDN"
        }
        #
        # actually, make_a_pool CAN make a pool from
        # a single IP in place of an FQDN...  but it
        # is too confusing to exploit that here
        #

        if {($h eq "") || ($p eq "*") || ($p < 1) || ($p > 65534)} {
            fail "You must supply proxy FQDN and port number"
        }

        ### proc- make_a_pool {scr_debug ripe tg usage fqdn rd port name_pfx is_api_svr}
        set ::f5xcc_proxy_pool_name [make_a_pool $::runtime_debug $::api_svr_ripe $::api_svr_tg "proxy2api" $h $::api_svr_rd $p $::myRDPrefix false]
        return
    }

    # otherwise proxy_pool_source is create-new-from-IP-addrs
    set members [list]
    foreach {row} $::api__proxy_pool_ips {
        set ip [tmsh::get_field_value $row proxy_ip]
        set port [tmsh::get_field_value $row proxy_port]
        if {[string first "%" $ip] < 0} {
            append ip "%" $::api_svr_rd
        }
        if {$port eq "*"} {
            fail "You must supply port for proxy server ${ip}"
        }
        lappend members [list $ip $port]
    }
    if {![llength $members]} {
        fail "You must supply at least one proxy IP address!"
    }

    set ::f5xcc_proxy_pool_name "${::myRDPrefix}proxy2api"

    if {([set tmp [load "proxy2api_pool"]] ne "") &&
                ($tmp ne $::f5xcc_proxy_pool_name)} {
        iapp::conf "delete / ltm pool '${tmp}'"
        store "proxy2api_pool" ""
    }

    set lb_mode [expr {[have_license ltm_lb_predictive] ? "predictive-member" : "round-robin"}]
    set monitor [expr {[have_license ltm_monitor_inband] ? "inband" : "tcp_half_open"}]

    lnew c "create / ltm pool '${::f5xcc_proxy_pool_name}'"
    if {!$::api_svr_aso} {
        lappend c "app-service none"
        store "proxy2api_pool" $::f5xcc_proxy_pool_name
    }
    lappend c "load-balancing-mode ${lb_mode}"
    lappend c "monitor ${monitor}"
    lappend c "members replace-all-with \x7b"
        foreach {member} $members {
            foreach {h p} $member { break }
            set psep [expr {([string first ":" $h] > 0) ? "." : ":"}]

            lappend c "${h}${psep}${p}"
        }
    lappend c "\x7d"
    iapp::conf [join $c]
} ; #config_proxy_pool

proc init {} {
    puts "init --------"

    # ---------- Internal Data Groups Names -----------------------
    set ::GET_DG "${::iapp_prefix}GETEndpoints"
    set ::POST_DG "${::iapp_prefix}POSTEndpoints"
    set ::PUT_DG  "${::iapp_prefix}PUTEndpoints"
    set ::ANY_DG  "${::iapp_prefix}ANYEndpoints"
    set ::PROTECTED_DG "${::iapp_prefix}PROTECTEDEndpoints"
    set ::ISTL_DG "${::iapp_prefix}ISTLEndpoints"
    set ::MSDK_HDRS_DG "${::iapp_prefix}MSDKHdrs"
    set ::BLOCK_BODY_DG "${::iapp_prefix}BlockBody"

    # Should iRules log to HSL?
    set ::hsl_pub ""
    if {[info exists ::advanced_features__hsl_use] && $::advanced_features__hsl_use} {
        set ::hsl_pub $::advanced_features__hsl_pub
    }

    # Should request log message include any request headers?
    set tmp [expr {[info exists ::advanced_features__log_x__hdrs] ?
                                    $::advanced_features__log_x__hdrs : ""}]
    if {($tmp ne "") && ![regsub {^\(\?([^)]+)\)} $tmp {(?\1i)} tmp]} {
        set tmp "(?i)${tmp}"
    }
    set ::xlog_hdrs $tmp

    # Format log messages in JSON?
    set ::log_json 0
    if {[info exists ::advanced_features__log_json]} {
        set ::log_json $::advanced_features__log_json
    }

    # ---------- API Pool Configuration -------------------------
    set ::api_snatpool_name "${::iapp_prefix}ApiSNATpool"


    set ::ALLOW_IP_DG "${::iapp_prefix}allowed_ip"
    set ::HEADER_DG "${::iapp_prefix}allowed_headers"
} ; #proc init


# Remove irules that created by the Iapp from the VS.
proc clean_vs_irules {vs_name vs_obj rules_list} {
    puts "clean irules----"

    regsub -all "/" ${vs_name} "_" format_vs_name
    set formated_rule_name "${::f5xcc_irule_name}_${format_vs_name}"

    set idx [lsearch -exact $rules_list $formated_rule_name]
    if {$idx >= 0} {
        set rules_list [lreplace $rules_list $idx $idx]
    }

    if {[llength $rules_list]} {
        tmsh_modify "/ ltm virtual" "$vs_name rules { $rules_list }"
    } else {
        tmsh_modify "/ ltm virtual" "$vs_name rules none"
    }
} ; #clean_vs_irules

# Detach all iApp components before reconfigured
proc cleanup {} {
    puts "cleanup --------"

    foreach {vs} [tmsh::get_config /ltm virtual] {
        set vs_name [tmsh::get_name $vs]
        regsub -all "/" ${vs_name} "_" format_vs_name
        puts "========= clenup $vs_name ==============="
        # Clean irules only and profiles only for VS that not requested to configured.
        # The VSs that should be configured will cleanup automaticlly by the iApp
        if {([lsearch -exact [tmsh::get_field_names value $vs] "rules"] < 0) ||
            ([iapp::is ::general__clean No] && [lsearch -exact ${::vs_config__vs} $vs_name] != -1) } {
            puts "No attached iRules for $vs_name"
            continue
        }
        set rules_list [tmsh::get_field_value $vs rules]

        # In case of f5xcc web/msdk vs, we can remove all irules and deattch the pool
        if {($vs_name eq $::f5xcc_web_vs_name) ||
            ($vs_name eq $::f5xcc_msdk_vs_name)} {

            #906 - clean these up separately

            # tmsh_modify "/ ltm virtual" "$vs_name rules none"
            # tmsh_modify "/ ltm virtual" "$vs_name pool none"
        } else {
            clean_vs_irules $vs_name $vs $rules_list
        }

        set apgIappExist [lsearch $rules_list *APG*]
        # Support for IBD and APG iapps simultany. If the VS contain IBD irules, and the HTML profile created by this iApp, search for APG HTML profile and replace it.
        #The HTML rule created by the iApp itself ==> should deattch it.
        if { [string compare $::f5xcc_inject_html_profile_name [find_profile $vs "profile" "html"]] == 0} {
            if { $apgIappExist == -1} {
                # APG iApp not exist and it created by the iApp itself, therfore, just deattacth the HTML profile
                catch { tmsh_modify "/ ltm virtual" "$vs_name profiles delete { $::f5xcc_inject_html_profile_name }" }
            } else {
                # Should set the APG HTML profiles
                # first, check if the html profile already set for IBD iApp
                if { [string last "APG_JsHtml" [find_profile $vs "profile" "html"] ] == -1 } {
                    foreach {html_profile} [tmsh::get_config /ltm profile html] {
                        set html_profile_name [lindex $html_profile 3]
                        # Check if the APG HTML profile exist
                        if {[string last "APG_JsHtml" $html_profile_name ] != -1} {
                            tmsh_modify "/ ltm virtual" "$vs_name profiles delete { $::f5xcc_inject_html_profile_name } profiles add { $html_profile_name }"
                            # Add the rules that attached to this HTML profiles
                            set html_obj [lindex [tmsh::get_config /ltm profile html ${::f5xcc_inject_html_profile_name} rules] 0]
                            set html_rules [tmsh::get_field_value $html_obj rules]
                            # add the exist rules to the replaced HTML profile except of the current iApp rule
                            foreach {rule_name} $html_rules {
                                if {($rule_name eq $::html_js_rule_name) ||
                                        ($rule_name eq $::html_iojs_rule_name)} {
                                    catch {tmsh_modify "/ ltm profile" "html ${::f5xcc_inject_html_profile_name} rules delete { ${rule_name} }" }
                                    continue
                                }
                                catch { tmsh_modify "/ ltm profile" "html ${html_profile_name} rules add { ${rule_name} }" }
                            }
                            break
                        }
                    }
                }
            }
        }
    }

    detach_html_rules

} ; #proc cleanup

proc clean_last {} {
    puts "clean_last --------"

    foreach {usage} {web msdk} {
        if {[set tmp [load "${usage}_handler"]] ne ""} {
            lnew c "delete sys icall handler periodic '${tmp}'"
            iapp::conf [join $c]
            store "${usage}_handler" ""
        }

        if {[set tmp [load "${usage}_pool"]] ne ""} {

     #TODO: HLS-404 >>>
     # not sure removing these nodes is safe because
     # some other ASO may be using them (to reach SSE)
     if {"HLS-404" eq "THIS FIX"} {
            catch {
                set mbrs [lindex [tmsh::get_config / ltm pool $tmp] 0 3 3]
                set killem [list]
                foreach {n v} $mbrs {
                    lappend killem $n
                }
                if {[llength $killem]} {
                    foreach {n} $killem {
                        tmsh::modify / ltm pool $tmp members delete "{ ${n} }"
                        tmsh::delete / ltm node [regsub {:.*$} $n {}]
                    }
                }
            }
     }
     #<<< HLS-404

            iapp::conf "delete / ltm pool '${tmp}'"
            store "${usage}_pool" ""
        }

     #TODO: HLS-404 >>>
     # not sure removing these nodes is safe because
     # some other ASO may be using them (to reach SSE)
     if {"HLS-404" eq "THIS FIX"} {
        if {[set tmp [load "${usage}_fqdn"]] ne ""} {
            foreach {a} [tmsh::get_config / ltm node] {
                set n [lindex $a 2]
                if {($n eq $tmp) ||
                    ( ([set x [lsearch -exact [lindex $a 3] "fqdn.name"]] >= 0) &&
                      ([lindex $a 3 [incr x]] eq $tmp) )} {
                    catch { tmsh::delete / ltm node $n }
                }
            }
            store "${usage}_fqdn" ""
        }
     }
     #<<< HLS-404

    } ; #foreach-usage

    if {[set tmp [load "proxy2api_pool"]] ne ""} {
        iapp::conf "delete / ltm pool '${tmp}'"
        store "proxy2api_pool" ""
    }

    if {[set tmp [load "inj_html_pfl"]] ne ""} {
        iapp::conf "delete / ltm profile html '${tmp}'"
        store "inj_html_pfl" ""
    }

} ; #proc clean_last


proc config_js_injection_settings {} {
    puts "config js injection----"

    set ::do_js_injection 0
    set js_injection_path ""

    set ::js_injection_tag ""
    set js_injection_position 0
    set teljs_snippet ""
    set iojs_snippet ""
    set ::telem_in_body 0

    set our_html_profile $::f5xcc_inject_html_profile_name

    if {( [info exists ::js_injection__inject_tags] &&
            ($::js_injection__inject_tags eq "Yes") ) &&
                ([set js_injection_path $::js_injection__injection_path] ne "")} {

        set ::do_js_injection 1

        if {[string range $js_injection_path 0 0] ne "/"} {
            regsub {(?i)^https?://} $js_injection_path "" js_injection_path
            regexp {^([^/]+)(.*)} $js_injection_path junk host path
            if {$host ne ""} {
                set js_injection_path "[string tolower $host]${path}"
            }
        }

        set ::js_injection_tag [get_tag_name $::js_injection__injection_location]
        if {$::js_injection_tag ne ""} {
            if {[get_tag_location $::js_injection__injection_location] eq "tag-prepend-html"} {
                set js_injection_position 1
            }
            tmsh_create "/ ltm html-rule" "tag-raise-event ${::html_iojs_rule_name} { match { tag-name ${::js_injection_tag} } }"
        }

        if {[info exists ::js_injection__inject_telemetryjs_in_body] &&
                    ($::js_injection__inject_telemetryjs_in_body eq "Yes")} {
            set ::telem_in_body 1
            tmsh_create "/ ltm html-rule" "tag-raise-event ${::html_js_rule_name} { match { tag-name body } }"
        }

        # $::js_injection__async_enable has no effects in ibd mode
        set teljs_snippet "<script type=\"text/javascript\" src=\"$::js_injection__injection_path?async\" async></script>"
        set iojs_snippet "<script type=\"text/javascript\" src=\"$::js_injection__injection_path?matcher\"></script><script type=\"text/javascript\" src=\"$::js_injection__injection_path?cache\"></script>"

        # Create HTML profile
        lnew c "create / ltm profile html [tmsh_escape $our_html_profile]"
        #
        # 906: their oughta to be some way to keep this in ASO
        #
        lappend c "app-service none"
        store "inj_html_pfl" $our_html_profile
        #
        lappend c "defaults-from /Common/html"
        lappend c "content-detection disabled"
        lappend c "content-selection replace-all-with \x7b"
         lappend c "text/html text/xhtml"
        lappend c "\x7d"
        lappend c "rules replace-all-with \x7b"
         if {$::js_injection_tag ne ""} { lappend c [tmsh_escape $::html_iojs_rule_name] }
         if {$::telem_in_body} { lappend c [tmsh_escape $::html_js_rule_name] }
        lappend c "\x7d"
        lappend c "description none"
        iapp::conf [join $c]

        # need HTML profile to hook HTML_TAG_MATCHED event
        ### Not sure why regsub messes up here, but use string-replace instead
        ### regsub __HTML_TAG_MATCHED__ $::prep_irule $::htm_evt ::prep_irule
        if {[set x [string first "__HTML_TAG_MATCHED__" $::prep_irule]] >= 0} {
            set ::prep_irule [string replace $::prep_irule $x [incr x 19] $::htm_evt]
        } else {
            fail "Unable to add HTML_TAG_MATCHED event to IBD iRule"
        }
    } else {
        catch {
            iapp::conf "delete / ltm profile html [tmsh_escape $our_html_profile]"
        }
        regsub __HTML_TAG_MATCHED__ $::prep_irule "" ::prep_irule
    }

    regsub __JS_INJ_PATH__ $::prep_irule $js_injection_path ::prep_irule
    regsub __JS_INJ_ENABLE__ $::prep_irule $::do_js_injection ::prep_irule

    regsub __JS_INJ_TAG__ $::prep_irule $::js_injection_tag ::prep_irule
    regsub __JS_INJ_POSITION__ $::prep_irule $js_injection_position ::prep_irule
    regsub __JS_INJ_TEL_IN_BODY__  $::prep_irule $::telem_in_body ::prep_irule
    regsub __JS_INJ_IO__ $::prep_irule $iojs_snippet ::prep_irule
    regsub __JS_INJ_TEL__ $::prep_irule $teljs_snippet ::prep_irule
}

proc collect_endpoints {protected_endpoints_tbl do_msdk do_adv_ept isIappMitigation ign_case} {
    puts "collect endpoints----"

    set ANY_EP_members [list]
    set GET_EP_members [list]
    set POST_EP_members [list]
    set PUT_EP_members [list]

    set PROTECTED_EP_members [list]

    # as of v3.0.3, no UI support for adv_ept (that is, regex path matching)
    set glob_path [expr {!$do_adv_ept}]

    set ctr -1
    foreach {member} $protected_endpoints_tbl {
        #pound-sign 0x23 forbidden in host and path

        set eph [string tolower [tmsh::get_field_value $member dsthost]]
        set eph [string map [list "#" "" "^" "" "$" "" "/" ""] $eph]
        set eph [regsub {:[0-9]*$} $eph ""]
        if {$eph eq ""} { continue }
        set eph "^[string map $::glob2rex $eph](:\x5b0-9\x5d*)?$"

        set endpoint $eph

        set epp [tmsh::get_field_value $member endpoint]
        set epp [string map [list "#" ""] $epp]
        if {$epp eq ""} { continue }

        #TODO:  enforce length limit 2047 and no [xyz] expressions

        set i 0
        if {$glob_path} {
            set tmp "^[string map $::glob2rex $epp]$"

            if {$ign_case} {
                set i 1
            }
            #earlier versions of iApp forced case-insensitive
            #matching but we are removing that for portability
        } else {
            # TODO:  you can disable case-sensitivity in your regex,
            # but we aren't yet (if ever?) mapping other (?xyz) options
            # from TCL ARE regex to client-side ECMAScript regex

            set i [regsub {^\(\?[^)i]*i[^)]*\)} $epp "" tmp]
        }
        set ecma_tmp [string map [list "/" "\x5c/"] $tmp]
        set ecma_path "/${ecma_tmp}/[expr {$i ? "i" : ""}]"

        append endpoint "#" [expr {$ign_case ? "(?i)" : ""}] $tmp

        append endpoint "#"
        set epq "[tmsh::get_field_value $member query]"
        if {$epq ne ""} {
            if {[string first "?" $epq] == 0} {
                set epq [string range $epq 1 end]
            }
            set epq [string map [list "#" ""] $epq]
            append endpoint $epq
        }

        append endpoint "#"
        if {$do_msdk && ([string first "m" [set ept [tmsh::get_field_value $member ept]]] >= 0)} {
            set mid [tmsh::get_field_value $member mid]
            if {[string first "w" $ept] < 0} {
                append endpoint "M" $mid
            } else {
                #oooh, Both
                if {$mid ne "_"} { append endpoint "B" $mid }
            }
        }

        binary scan $endpoint H* endpoint

        set action [expr {$isIappMitigation ?
                          [tmsh::get_field_value $member action] :
                          "unknown"}]

        set tmp [tmsh_escape "${endpoint}~[string tolower $action]"]
        set val "[incr ctr] { data ${tmp} }"

        if {[tmsh::get_field_value $member ANY] eq "Yes"} {
            lappend ANY_EP_members $val
        } else {
            if {[tmsh::get_field_value $member GET] eq "Yes"} {
                lappend GET_EP_members $val
            }
            if {[tmsh::get_field_value $member POST] eq "Yes"} {
                lappend POST_EP_members $val
            }
            if {[tmsh::get_field_value $member PUT] eq "Yes"} {
                lappend PUT_EP_members $val
            }
        }

        foreach {method} [list "ANY" "GET" "POST" "PUT"] {
            if {[tmsh::get_field_value $member $method] eq "Yes"} {
                set tmp "\x7b"
                append tmp "protocol:/^https?$/i,"
                append tmp "host:/${eph}/i,"
                append tmp "path:${ecma_path},"
                append tmp "method:'[string tolower $method]'"
                append tmp "\x7d"
                binary scan $tmp H* entry_ep

                set val "[incr ctr] { data [tmsh_escape $entry_ep] }"
                lappend PROTECTED_EP_members $val

                if {$method eq "ANY"} {
                    # ANY acts as a wildcard
                    break
                }
            }
        }

    } ; #foreach in protected_endpoints_tbl

    if {[llength $GET_EP_members]} {
        tmsh_create "/ ltm data-group" "internal ${::GET_DG} records replace-all-with { [join $GET_EP_members] } type integer"
    }
    if {[llength $POST_EP_members]} {
        tmsh_create "/ ltm data-group" "internal ${::POST_DG} records replace-all-with { [join $POST_EP_members] } type integer"
    }
    if {[llength $PUT_EP_members]} {
        tmsh_create "/ ltm data-group" "internal ${::PUT_DG} records replace-all-with { [join $PUT_EP_members] } type integer"
    }
    if {[llength $ANY_EP_members]} {
        tmsh_create "/ ltm data-group" "internal ${::ANY_DG} records replace-all-with { [join $ANY_EP_members] } type integer"
    }

    if {[llength $PROTECTED_EP_members]}  {
        tmsh_create "/ ltm data-group" "internal $::PROTECTED_DG records replace-all-with { [join $PROTECTED_EP_members] } type integer"
    }
} ; #collect_endpoints

proc collect_istl_endpoints {protected_endpoints_tbl do_adv_ept isIappMitigation ign_case} {
    puts "collect ISTL endpoints----"

    # as of v3.0.3, no UI support for adv_ept (that is, regex path matching)
    set glob_path [expr {!$do_adv_ept}]

    set ctr -1
    set ISTL_EP_members [list]
    foreach {member} $protected_endpoints_tbl {
        #pound-sign 0x23 forbidden in host and path

        set eph [string tolower [tmsh::get_field_value $member dsthost]]
        set eph [string map [list "#" "" "^" "" "$" "" "/" ""] $eph]
        set eph [regsub {:[0-9]*$} $eph ""]
        if {$eph eq ""} { continue }
        set eph "^[string map $::glob2rex $eph](:\x5b0-9\x5d*)?$"

        set endpoint $eph

        set epp [tmsh::get_field_value $member endpoint]
        set epp [string map [list "#" ""] $epp]
        if {$epp eq ""} { continue }

        #TODO:  enforce length limit 2047 and no [xyz] expressions

        if {$glob_path} {
            set epp "^[string map $::glob2rex $epp]$"
            if {$ign_case} {
                set epp "(?i)${epp}"
            }
        }
        append endpoint "#" $epp

        append endpoint "#"
        set epq "[tmsh::get_field_value $member query]"
        if {$epq ne ""} {
            if {[string first "?" $epq] == 0} {
                set epq [string range $epq 1 end]
            }
            set epq [string map [list "#" ""] $epq]
            append endpoint $epq
        }

        append endpoint "#"
        # There is no MSDK match-id to append here

        binary scan $endpoint H* endpoint

        set action [expr {$isIappMitigation ?
                          [tmsh::get_field_value $member action] :
                          "unknown"}]

        set tmp [tmsh_escape "${endpoint}~[string tolower $action]"]
        set val "[incr ctr] { data ${tmp} }"

        lappend ISTL_EP_members $val
    }

    if {[llength $ISTL_EP_members]} {
        tmsh_create "/ ltm data-group" "internal $::ISTL_DG records replace-all-with { [join $ISTL_EP_members] } type integer"
    }
} ; #collect_istl_endpoints

proc config {} {
    puts "config ------"

    # Init the template
    init

    # reset any partition info user may have messed up
    if {$::mypartn ne "Common"} {
     lnew c "modify /sys application service ${::myapp}"
     lappend c "variables modify \x7b"
      lappend c "api__ptn__partn \x7b"
       lappend c "value [tmsh_escape $::mypartn]"
      lappend c "\x7d"
      lappend c "api__ptn__rd \x7b"
       lappend c "value [tmsh_escape $::myRD]"
      lappend c "\x7d"
      lappend c "api__ptn__tg \x7b"
       lappend c "value [tmsh_escape $::myTG]"
      lappend c "\x7d"
     lappend c "\x7d"
     iapp::conf [join $c]
    }

    set INCL_JS_DG "${::iapp_prefix}JSincludedPaths"
    set EXCL_JS_DG "${::iapp_prefix}JSexcludedPaths"

    set my_version [expr {[info exists ::hidden__my_version] ? $::hidden__my_version : "3.0.4b"}]

    #craft an IBD iRule
    regsub -all {__IAPP_VERSION__} $::f5xcc_sed_irule $my_version ::prep_irule

    regsub {__IAPP_NAME__} $::prep_irule $::iapp_name ::prep_irule
    regsub {__UPDATED__} $::prep_irule "[clock seconds]_[clock clicks]" ::prep_irule

    set ir_myapp_pfx [regsub {/} [string range $::iapp_name 1 end] {~}]
    regsub -all {__MYAPP__} $::prep_irule $ir_myapp_pfx ::prep_irule

    set log_facility [expr {[info exists ::advanced_features__log_facility] ? $::advanced_features__log_facility : "16"}] ; #default=local0
    regsub __LOG_FAC__ $::prep_irule $log_facility ::prep_irule
    set log_level [expr {[info exists ::advanced_features__log_level] ? $::advanced_features__log_level : "error"}]
    set pri_map [list debug 7 info 6 notice 5 warning 4 warn 4 error 3 err 3 critical 2 crit 2 alert 1 emergency 0 emerg 0]
    set pri_level [expr {[string map $pri_map $log_level] + (8 * $log_facility)}]
    regsub __LOG_PRI__ $::prep_irule $pri_level ::prep_irule

    set ::runtime_debug [expr {$log_level eq "debug"}]
    regsub __DEBUG__ $::prep_irule $::runtime_debug ::prep_irule

    # what request headers should request log messages include (regex)?
    regsub __XLOG_HDRS__ $::prep_irule $::xlog_hdrs ::prep_irule

    # Should iRules log to HSL log publisher?
    regsub __HSL_PUB__ $::prep_irule $::hsl_pub ::prep_irule

    # Should iRules log in JSON format?
    regsub -all __LOG_JSON__ $::prep_irule $::log_json ::prep_irule

    # Put allowed-IP's into datagroup
    puts "create data group for allowed ips----"
    set allowed_ips [list]
    if {[info exists ::allow__allow_ips]} {
        foreach {member} $::allow__allow_ips {
            if {[set tmp [tmsh::get_field_value $member ip]] ne ""} {
                lappend allowed_ips $tmp
            }
        }
    }
    if {[llength $allowed_ips]} {
        tmsh_create "/ ltm data-group" "internal ${::ALLOW_IP_DG} { records replace-all-with { [join $allowed_ips] } type ip }"
    }

    # Create Data Group for allowed headers
    puts "create data group for allowed headers----"

    set allow_headers [list]
    set ctr -1
    if {[info exists ::allow__allow_adv] && $::allow__allow_adv} {
        foreach {hdr} $::allow__allow_hdrs {
            if {[set tmp [tmsh::get_field_value $hdr name]] eq ""} {
                continue
            }
            if {![regsub {^\(\?([^)]+)\)} $tmp {(?\1i)} h]} {
                set h "(?i)${tmp}"
            }
            binary scan $h H* xh

            if {[set v [tmsh::get_field_value $hdr value]] eq ""} {
                continue
            }
            binary scan $v H* xv

            lappend allow_headers "[incr ctr] { data [tmsh_escape "${xh}~${xv}"] }"
        }
    } else {
        foreach {hdr} $::allow__allow_header {
            set h [string tolower [tmsh::get_field_value $hdr name]]
            if {($h eq "") ||
                        ([set v [tmsh::get_field_value $hdr value]] eq "")} {
                continue
            }
            regsub -all {[\x00-\x20\x7f:]} $h "" h
            binary scan "(?i)^${h}$" H* xh
            binary scan "^[string map $::glob2rex $v]$" H* xv

            lappend allow_headers "[incr ctr] { data [tmsh_escape "${xh}~${xv}"] }"
        }
    }
    if {[llength $allow_headers]} {
        tmsh_create "/ ltm data-group" "internal ${::HEADER_DG} { records replace-all-with { [join $allow_headers] } type integer }"
    }

    #MSDK support enabled?
    set ::do_msdk [expr {[info exists ::m__msdk] && $::m__msdk}]
    puts "MSDK support enabled = ${::do_msdk}"

    set msdk_headers [list]
    set ctr -1
    if {$::do_msdk && [info exists ::m__hdrs]} {
        puts "create MSDK headers datagroup----"
        foreach {hdr} $::m__hdrs {
            if {[set tmp [tmsh::get_field_value $hdr name]] eq ""} {
                continue
            }
            if {![regsub {^\(\?([^)]+)\)} $tmp {(?\1i)} h]} {
                set h "(?i)${tmp}"
            }
            binary scan $h H* xh

            if {[set v [tmsh::get_field_value $hdr value]] eq ""} {
                continue
            }
            binary scan $v H* xv

            lappend msdk_headers "[incr ctr] { data [tmsh_escape "${xh}~${xv}"] }"
        }
    }
    if {[llength $msdk_headers]} {
        tmsh_create "/ ltm data-group" "internal ${::MSDK_HDRS_DG} records replace-all-with { [join $msdk_headers] } type integer"
    }

    regsub __MSDK_ENABLE__ $::prep_irule $::do_msdk ::prep_irule
    set reload_hdr [expr {$::do_msdk ? $::m__reload_hdr : ""}]
    regsub __MSDK_RELOAD_HDR__ $::prep_irule $reload_hdr ::prep_irule
    set body_regex [expr {$::do_msdk ? $::m__words__words : ""}]
    regsub __MSDK_BODY_REGEX__ $::prep_irule $body_regex ::prep_irule

    # Create the data groups for each protected configured endpoint
    puts "create protected endpoints datagroups----"

    set x_endpoint_table [expr {$::do_msdk ?
                $::protected_endpoints__endpoint_table_msdk :
                  $::protected_endpoints__endpoint_table_iapp}]
    set ign_case [expr {[info exists ::protected_endpoints__ignore_case] ? $::protected_endpoints__ignore_case : 0}]

    # The proc collect_endpoints gets the relevant table and if isIappMitigation
    collect_endpoints $x_endpoint_table $::do_msdk false 1 $ign_case

    set tmp [expr {($::mitigation_settings__add_header && [info exists ::mitigation_settings__header_hame]) ? $::mitigation_settings__bot_header_name : ""}]
    regsub __CONTINUE__ $::prep_irule $tmp ::prep_irule
    regsub __REDIRECT__ $::prep_irule $::mitigation_settings__redirect_path_iApp ::prep_irule
    regsub __BLOCK_CODE__ $::prep_irule $::mitigation_settings__block_data_iApp__rc ::prep_irule

    set block_body $::mitigation_settings__block_data_iApp__body
    if {[string range $block_body end end] ne "\n"} {
        append block_body "\\r\\n"
    }
    regsub __BLOCK_BODY_DG__ $::prep_irule $::BLOCK_BODY_DG ::prep_irule
    tmsh_create "/ ltm data-group" "internal ${::BLOCK_BODY_DG} records replace-all-with { 0 { data [tmsh_escape $block_body] } } type integer"

    # Create the data groups for each configured istl protected endpoint
    puts "create ISTL protected endpoints datagroup----"
    # The proc collect_istl_endpoints gets the relevant table and if isIappMitigation
    set ign_case [expr {[info exists ::istl_protected_endpoints__ignore_case] ? $::istl_protected_endpoints__ignore_case : 0}]
    collect_istl_endpoints $::istl_protected_endpoints__endpoint_table_iapp false 1 $ign_case

    regsub __INCL_JS_DG__ $::prep_irule $INCL_JS_DG ::prep_irule
    regsub __EXCL_JS_DG__ $::prep_irule $EXCL_JS_DG ::prep_irule
    regsub __KILL_SWITCH__ $::prep_irule [iapp::is ::general__kill_switch Yes] ::prep_irule
    if {[info exists ::general__filter_body]} {
        regsub __FILTER_API_BODY__ $::prep_irule $::general__filter_body ::prep_irule
    }
    regsub -all __GET_EP_DG__ $::prep_irule $::GET_DG ::prep_irule
    regsub -all __POST_EP_DG__ $::prep_irule $::POST_DG ::prep_irule
    regsub -all __PUT_EP_DG__ $::prep_irule $::PUT_DG ::prep_irule
    regsub -all __ANY_EP_DG__ $::prep_irule $::ANY_DG ::prep_irule
    regsub -all __PROTECTED_EP_DG__ $::prep_irule $::PROTECTED_DG ::prep_irule

    regsub -all __ISTL_EP_DG__ $::prep_irule $::ISTL_DG ::prep_irule

    regsub -all __MSDK_HEADERS_DG__ $::prep_irule $::MSDK_HDRS_DG ::prep_irule

    regsub __ALLOW_HEADER_DG__ $::prep_irule $::HEADER_DG ::prep_irule
    regsub __ALLOW_IPS_DG__ $::prep_irule $::ALLOW_IP_DG ::prep_irule
    regsub __TIMEOUT__ $::prep_irule $::api__timeout ::prep_irule
    regsub __API_APPLICATION_ID__ $::prep_irule "$::api__application_id" ::prep_irule

    regsub __USE_PROXY__ $::prep_irule [iapp::is ::api__proxy Yes] ::prep_irule

    #call proc to get API server hostnames
    get_api_params

    if {$::api__proxy eq "Yes"} {
        set proxy_auth_b64 ""
        if {$::api__proxy_auth eq "Yes"} {
            set proxy_auth_b64 [base64::encode "${::api__creds__username}:${::api__creds__passcode}"]
        }
        regsub __PROXY_AUTH_B64__ $::prep_irule $proxy_auth_b64 ::prep_irule

        ###regsub __PROXY_URL__ $::prep_irule "$::api__proxy_url" ::prep_irule
        ###regsub __PROXY_HOST_IP__ $::prep_irule "$::api__proxy_host" ::prep_irule
        ###regsub __PROXY_PORT__ $::prep_irule "$::api__proxy_port" ::prep_irule
        regsub __PROXY_CONNECT_EVENT__ $::sband_helper_irule "$::sband_proxy_connect_event" ::sband_helper_irule

        # config f5xcc proxy pool
        config_proxy_pool
    } else {
        regsub __PROXY_CONNECT_EVENT__ $::sband_helper_irule "" ::sband_helper_irule
        regsub __PROXY_AUTH_B64__ $::prep_irule "" ::prep_irule

        # config web API pool
        config_web_api_pool

        if {$::do_msdk} {
            config_msdk_api_pool
        }
    }
    regsub __CLUSTER_FQDN__ $::prep_irule $::web_api_fqdn ::prep_irule
    regsub __MSDK_API_FQDN__ $::prep_irule [expr {$::do_msdk ? $::msdk_api_fqdn : ""}] ::prep_irule

    # substitute javascript injection settings for iRule to consume
    config_js_injection_settings

    # The user specific web pages (entry pages) for injection
    puts "create JS injection datagroups----"

    set js_included_flag 0
    set js_excluded_flag 0

    if {[info exists ::js_injection__inject_tags] &&
                        ($::js_injection__inject_tags eq "Yes")} {
        if {[info exists ::js_injection__inject_by_endpoint] &&
                        ($::js_injection__inject_by_endpoint eq "Yes")} {
            # Collect the injected entry points
            set js_include_paths [list]
            set ctr -1
            foreach {member} $::js_injection__injected_ep {
                set path [tmsh::get_field_value $member end_point]

                #pound-sign 0x23 forbidden in path
                set path [string map [list "#" ""] $path]
                if {$path eq ""} { continue }
                set item "^[string map $::glob2rex $path]$"

                ##TODO:
                set query ""
                ## set query [tmsh::get_field_value $member query]
                ## if {$query ne ""} {
                ##     if {[string first "?" $query] == 0} {
                ##         set query [string range $query 1 end]
                ##     }
                ##     set query [string map [list "#" ""] $query]
                ## }
                append item "#${query}"

                binary scan $item H* xitem

                lappend js_include_paths "[incr ctr] { data [tmsh_escape $xitem] }"
            }
            if {[llength $js_include_paths]} {
                tmsh_create "/ ltm data-group" "internal ${INCL_JS_DG} records replace-all-with { [join $js_include_paths] } type integer"
                set js_included_flag 1
            }
        }

        if {[info exists ::js_injection__exclude_endpoint] &&
                        ($::js_injection__exclude_endpoint eq "Yes")} {
            # Collect the excluded entry points
            set js_exclude_paths [list]
            set ctr -1
            foreach {member} $::js_injection__excluded_ep {
                set path [tmsh::get_field_value $member end_point]

                #pound-sign 0x23 forbidden in path
                set path [string map [list "#" ""] $path]
                if {$path eq ""} { continue }
                set item "^[string map $::glob2rex $path]$"

                ##TODO:
                set query ""
                ## set query [tmsh::get_field_value $member query]
                ## if {$query ne ""} {
                ##     if {[string first "?" $query] == 0} {
                ##         set query [string range $query 1 end]
                ##     }
                ##     set query [string map [list "#" ""] $query]
                ## }
                append item "#${query}"

                binary scan $item H* xitem

                lappend js_exclude_paths "[incr ctr] { data [tmsh_escape $xitem] }"
            }
            if {[llength $js_exclude_paths]} {
                tmsh_create "/ ltm data-group" "internal ${EXCL_JS_DG} records replace-all-with { [join $js_exclude_paths] } type integer"
                set js_excluded_flag 1
            }
        }
    }
    regsub __JS_INJECT_INCL__ $::prep_irule $js_included_flag ::prep_irule
    regsub __JS_INJECT_EXCL__ $::prep_irule $js_excluded_flag ::prep_irule


    # Inject XFF flag into irule
    regsub __XFF__ $::prep_irule [iapp::is ::advanced_features__xff Yes] ::prep_irule

    # and Expect-100 mode
    regsub __XPCT100__ $::prep_irule [iapp::is ::advanced_features__xpct100 1] ::prep_irule

    #sband_helper_irule
    puts "create sideband helper irule----"

    lnew c "create ltm rule [tmsh_escape $::sband_helper_irule_name]"
    lappend c "{ ${::sband_helper_irule} }"
    iapp::conf [join $c]

    #prepare WEB/MSDK API VS SNAT
    #if customer fails to provide SNAT addresses or pool we just automap
    puts "possibly make_api_snatpool----"

    if {($::api__snatmode == 1) && [make_api_snatpool]} {
     set snat $::api_snatpool_name
    } elseif {($::api__snatmode == 2) &&
              [info exists ::api__snatpool] &&
              ([set snat $::api__snatpool] ne "")} {
     #okay then!
    } else {
     set snat "automap"
    }

    # select virtual-address for API-access virtual server(s)
    set ::api_vs_ip $::advanced_features__vip2vip_ip
    if {[regexp {%([0-9]*)$} $::api_vs_ip junk rd]} {
        if {$rd eq ""} {
            fail "Internal virtual server IP address route-domain invalid"
        }
    } else {
        append ::api_vs_ip $::add_RD
    }

    # Create vs for bigip -> WEB / MSDK
    puts "make_web_vs----"
    make_web_vs $snat
    regsub __SHAPE_WEB_VS_NAME__ $::prep_irule $::f5xcc_web_vs_name ::prep_irule

    if {$::do_msdk} {
        puts "make_msdk_vs----"
        make_msdk_vs $snat
        regsub __SHAPE_MSDK_VS_NAME__ $::prep_irule $::f5xcc_msdk_vs_name ::prep_irule
    }

    #iRules code snippet for use with HTTPS virtual servers
    set cssl_evt {
when CLIENTSSL_HANDSHAKE {
    set txdata(tls_cipher) [SSL::cipher name]
    set txdata(tls_alpn) [SSL::alpn]

    set tmp ""
    regexp {(?i)TLSv([0-9.]+)$} [SSL::cipher version] junk tmp
    set txdata(tls_ver:n) $tmp

    set I1_tls_sni ""
    set tmp ""
    if {![catch {SSL::extensions -type 0} tmp]} {
        if {$tmp ne ""} {
            binary scan $tmp @9a* I1_tls_sni
            set I1_tls_sni [string tolower $I1_tls_sni]
        }
    }
}
} ; #end of cssl_evt

    foreach {vs} ${::vs_config__vs} {
        puts "======= vs: $vs ========"
        set vs_obj [lindex [tmsh::get_config /ltm virtual ${vs}] 0]

        if {$::do_js_injection} {
            puts "do JS injection"

            # Add HTML profile if not exist
            set html_profile [find_profile $vs_obj "profile" "html"]

            if {$html_profile eq ""} {
                set html_profile $::f5xcc_inject_html_profile_name
                puts "vs lacks html profile so add ${html_profile}"
                catch { tmsh_modify "/ ltm virtual" "${vs} profiles add { ${html_profile} }" }
            } else {
                puts "modify vs current html profile '${html_profile}'"
                if {$::js_injection_tag ne ""} {
                    tmsh_modify "/ ltm profile" "html ${html_profile} rules add { ${::html_iojs_rule_name} }"
                }
                if {$::telem_in_body} {
                    tmsh_modify "/ ltm profile" "html ${html_profile} rules add { ${::html_js_rule_name} }"
                }
            }
        }

        # If customer has irules configured, we want to leave them active
        set customer_irules [list]
        catch {
            foreach {rule} [tmsh::get_field_value $vs_obj rules] {
                lappend customer_irules $rule
            }
        }
        puts "vs customer_irules: ${customer_irules}"

        set vs_irule ""
        # Replace '/' with '_' in order to name the iRule based on Virtual Server
        regsub -all "/" $vs "_" xvs_name
        set vs_irule_name "${::f5xcc_irule_name}_${xvs_name}"

        # Can our iRule pick up TLS info?
        set tmp [expr {([find_profile $vs_obj "profile" "client-ssl"] ne "") ?
                       $cssl_evt : ""}]
        regsub __CLIENTSSL_HANDSHAKE_EVENT__ $::prep_irule $tmp vs_irule

        puts "create ltm rule ${vs_irule_name} for vs..."

        set c [list "create ltm rule ${vs_irule_name}"]
        lappend c "{ ${vs_irule} }"
        iapp::conf [join $c]

        lappend customer_irules ${vs_irule_name}

        puts "update vs irules: ${customer_irules}"
        tmsh_modify "/ ltm virtual" "${vs} { rules { ${customer_irules} } }"
    } ; #foreach-target-vs

} ; #config

#*************
#***** Return the tag location, after or before tag. (0-> after, 1-> before)
#*************
proc get_tag_location {tag} {
    switch -- $tag {
        "After <head>" { return "tag-append-html"}
        "After </title>" { return "tag-append-html" }
        "After <body>" { return "tag-append-html" }
        "Before first <script>" { return "tag-prepend-html" }
    }
    # Default is after tag
    return "tag-append-html"
}

#*************
#***** Return the tag tag name
#*************
proc get_tag_name {tag} {
    puts "received tag: $tag"
    switch -- $tag {
        "After <head>" { return "head" }
        "After </title>" { return "/title" }
        "After <body>" { return "body" }
        "Before first <script>" { return "script" }
    }
    return $tag
}

#--------------------------------------------------------------------------

proc detach_303_html_rules {html_js_rule_name html_iojs_rule_name} {
    # html_profile does not exist until first deployment is completed
    set html_profiles [tmsh::get_config /ltm profile html]
    foreach {html_profile} $html_profiles {
        set html_profile_name [lindex $html_profile 3]
        catch { tmsh_modify "/ ltm profile" "html ${html_profile_name} rules delete { $html_js_rule_name }" }
        catch { tmsh_modify "/ ltm profile" "html ${html_profile_name} rules delete { $html_iojs_rule_name }" }
    }
} ; #detach_303_html_rules

proc clean_303_vs_irules {vs_name vs_obj rules_list sse_irule_name sband_irule_name} {

    tmsh_modify "/ ltm virtual" "$vs_name rules none"

    regsub -all "/" ${vs_name} "_" format_vs_name
    set formated_rule_name "$sse_irule_name\_${format_vs_name}"
    set idx [lsearch -exact $rules_list $formated_rule_name]
    if {$idx >= 0} {
        set rules_list [lreplace $rules_list $idx $idx]
    }

    set idx [lsearch -exact $rules_list $sband_irule_name]
    if {$idx >= 0} {
        set rules_list [lreplace $rules_list $idx $idx]
    }

    # check if TLS iRule exist
    set formated_rule_name  "${::iapp_name}_Shape_sse_TLSFP_iRule_${format_vs_name}"
    set idx [lsearch -exact $rules_list $formated_rule_name]
    if {$idx >= 0} {
        set rules_list [lreplace $rules_list $idx $idx]
    }
    if {[llength $rules_list]} { tmsh_modify "/ ltm virtual" "$vs_name rules { $rules_list }" }
} ; #clean_303_vs_irules

proc clean_303 {web_api_host msdk_api_host proxy_api_host} {
    set sse_irule_name "${::iapp_name}_IBD_iRule"
    set html_js_rule_name "${::iapp_name}_IBD_JSRule"
    set html_iojs_rule_name "${::iapp_name}_IBD_IOJSRule"
    set shape_inject_html_profile_name "${::iapp_name}_IBD_JsHtml"
    set iapp_oneconnect "${::iapp_name}_IBD_oneconnect"
    set sband_helper_irule_name "${::iapp_name}_SBand-helper"
    set helper_http_profile "${::iapp_name}_ibd_helper_http_profile"
    set helper_proxy_profile "${::iapp_name}_ibd_helper_proxy_profile"
    set helper_one_connect "${::iapp_name}_ibd_helper_one_connect"
    set shape_sse_vs_name "${::iapp_name}_IBD_shape_sse_vs"
    set shape_msdk_vs_name "${::iapp_name}_IBD_shape_msdk_vs"

    set shape_snatpool_name "${::iapp_name}_ShapeApiSNATpool"

    set shape_sse_pool_name "${::iapp_name}_ShapeProdPool"

    set shape_msdk_pool_name ""
    if {[info exists ::m__msdk] && $::m__msdk} {
        set shape_msdk_pool_name "${::iapp_name}_ShapeMSDKPool"
    }

    set shape_proxy_pool_name ""
    if {[info exists ::advanced_features__proxy] &&
            ($::advanced_features__proxy eq "Yes") &&
            [info exists ::advanced_features__proxy_pool_source] &&
            ($::advanced_features__proxy_pool_source equals "Create New")} {
        set shape_proxy_pool_name "${::iapp_name}_ShapeProxyPool"

        # when using proxy, not using regular pool(s)
        set shape_sse_pool_name ""
        set shape_msdk_pool_name ""
    }


    foreach {vs} [tmsh::get_config /ltm virtual] {
        set vs_name [tmsh::get_name $vs]
        regsub -all "/" ${vs_name} "_" format_vs_name
        puts "========= clenup $vs_name ==============="
        # Clean irules only and profiles only for VS that not requested to configured.
        # The VSs that should be configured will cleanup automaticlly by the iApp
        if {[lsearch -exact [tmsh::get_field_names value $vs] "rules"] < 0} {
            continue
        }
        set rules_list [tmsh::get_field_value $vs rules]

        # In case of shape sse/msdk vs, we can remove all irules and deattch the pool
        if {($vs_name eq $shape_sse_vs_name) ||
            ($vs_name eq $shape_msdk_vs_name)} {
            tmsh_modify "/ ltm virtual" "$vs_name rules none"
            tmsh_modify "/ ltm virtual" "$vs_name pool none"
        } else {
            clean_303_vs_irules $vs_name $vs $rules_list $sse_irule_name $sband_helper_irule_name
        }

        set apgIappExist [lsearch $rules_list *APG*]
        # Support for IBD and APG iapps simultany. If the VS contain IBD irules, and the HTML profile created by this iApp, search for APG HTML profile and replace it.
        #The HTML rule created by the iApp itself ==> should deattch it.
        if { [string compare $shape_inject_html_profile_name [find_profile $vs "profile" "html"]] == 0} {
            if { $apgIappExist == -1} {
                # APG iApp not exist and it created by the iApp itself, therfore, just deattacth the HTML profile
                catch { tmsh_modify "/ ltm virtual" "$vs_name profiles delete { $shape_inject_html_profile_name }" }
            } else {
                # Should set the APG HTML profiles
                # first, check if the html profile already set for IBD iApp
                if { [string last "APG_JsHtml" [find_profile $vs "profile" "html"] ] == -1 } {
                    foreach {html_profile} [tmsh::get_config /ltm profile html] {
                        set html_profile_name [lindex $html_profile 3]
                        # Check if the APG HTML profile exist
                        if {[string last "APG_JsHtml" $html_profile_name ] != -1} {
                            tmsh_modify "/ ltm virtual" "$vs_name profiles delete { $shape_inject_html_profile_name } profiles add { $html_profile_name }"
                            # Add the rules that attached to this HTML profiles
                            set html_obj [lindex [tmsh::get_config /ltm profile html ${shape_inject_html_profile_name} rules] 0]
                            set html_rules [tmsh::get_field_value $html_obj rules]
                            # add the exist rules to the replaced HTML profile except of the current iApp rule
                            foreach {rule_name} $html_rules {
                                if {($rule_name eq $html_js_rule_name) ||
                                        ($rule_name eq $html_iojs_rule_name)} {
                                    catch { tmsh_modify "/ ltm profile" "html $shape_inject_html_profile_name rules delete { $rule_name}" }
                                    continue
                                }
                                catch { tmsh_modify "/ ltm profile" "html $html_profile_name rules add { $rule_name }" }
                            }
                            break
                        }
                    }
                }
            }
        }

        if { [string compare $iapp_oneconnect [find_profile $vs "profile" "one-connect"]] == 0} {
            if { $apgIappExist == -1} {
                # APG iApp not exist and on-connect created by the iApp itself, therfore, just deattacth the profile
                catch { tmsh_modify "/ ltm virtual" "$vs_name profiles delete { $iapp_oneconnect}" }
            } else {
                if { [string last "APG_oneconnect" [find_profile $vs "profile" "one-connect"] ] == -1 } {
                    foreach {oneconnect_profile} [tmsh::get_config /ltm profile one-connect] {
                        set oneconnect_profile_name [lindex $oneconnect_profile 3]
                        if {[string last "APG_oneconnect" $oneconnect_profile_name ] != -1} {
                            tmsh_modify "/ ltm virtual" "$vs_name profiles delete { $iapp_oneconnect } profiles add { $oneconnect_profile_name }"
                            break
                        }
                    }
                }
            }
        }

        if {$helper_http_profile eq [find_profile $vs "profile" "http"]} {
            tmsh_modify "/ ltm virtual" "$vs_name profiles delete { ${helper_http_profile} }"
        }
        if {$helper_proxy_profile eq [find_profile $vs "profile" "http-proxy-connect"]} {
            tmsh_modify "/ ltm virtual" "$vs_name profiles delete { ${helper_proxy_profile} }"
        }
    }

    detach_303_html_rules $html_js_rule_name $html_iojs_rule_name

    foreach {tgt p} [list $web_api_host $shape_sse_pool_name $msdk_api_host $shape_msdk_pool_name $proxy_api_host $shape_proxy_pool_name] {
        if {$p eq ""} {
            if {$tgt ne ""} {
                foreach {a} [tmsh::get_config / ltm node] {
                    set n [lindex $a 2]
                    if {($n eq $tgt) ||
                        ( ([set x [lsearch -exact [lindex $a 3] "fqdn.name"]] >= 0) &&
                          ([lindex $a 3 [incr x]] eq $tgt) )} {
                        catch { tmsh::delete / ltm node $n }
                    }
                }
            }
            continue
        }

        catch {
            set mbrs [lindex [tmsh::get_config / ltm pool $p] 0 3 3]
            set killem [list]
            foreach {n v} $mbrs {
                lappend killem $n
            }
            if {[llength $killem]} {
                foreach {n} $killem {
                    tmsh::modify / ltm pool $p members delete "{ $n }"
                    tmsh::delete / ltm node [regsub {:.*$} $n {}]
                }
            }
        }
    }

    catch { tmsh::delete ltm virtual $shape_sse_vs_name }
    catch { tmsh::delete ltm virtual $shape_msdk_vs_name }

    catch { tmsh::delete ltm profile html ${shape_inject_html_profile_name} }

    catch { tmsh::delete ltm html-rule tag-raise-event $html_iojs_rule_name }
    catch { tmsh::delete ltm html-rule tag-raise-event $html_js_rule_name }
} ; #clean_303


#--------------------------------------------------------------------------



set ::newvals [list]
set ::modvals [list]

proc new_val {a b} {
    if {[info exists [set a]]} {
        set tmp [set [set a]]
        lappend ::newvals "${b} { value [tmsh_escape $tmp] }"
    }
} ; #new_val

proc mod_val {a b} {
    if {[info exists [set a]]} {
        set tmp [set [set a]]
        lappend ::modvals "${b} { value [tmsh_escape $tmp] }"
    }
} ; #mod_val

proc upgrade_from_303 {} {
    mod_val ::api_request_settings__application_id api__application_id
    mod_val ::api_request_settings__timeout api__timeout

    if {[string first "\x25\x25\x25" $::web_api_fqdn] == 0} {
        if {[info exists ::api_request_settings__cluster_fqdn] &&
                ($::api_request_settings__cluster_fqdn ne "")} {
            set web_api_host $::api_request_settings__cluster_fqdn
            mod_val ::api_request_settings__cluster_fqdn api__cluster_fqdn

            set msdk_api_host ""
            if {[info exists ::m__msdk] && $::m__msdk} {
                set msdk_api_host $::api_request_settings__msdk_api_fqdn
                mod_val ::api_request_settings__msdk_api_fqdn api__msdk_api_fqdn
            }
        } else {
            set rex {api_hosts. .list \x22([^\x22]*)\x22 \x22([^\x22]*)\x22}
            set h1 "" ; set h2 ""
            foreach {vs} $::vs_config__vs {
                if {$vs eq ""} { continue }
                set vsn [regsub -all "/" $vs "_"]
                set ir_name "${::iapp_name}_IBD_iRule_${vsn}"

                set h1 "" ; set h2 ""
                if {[catch {tmsh::get_config / ltm rule $ir_name} tmp]} {
                    continue
                }
                regexp $rex $tmp junk h1 h2
                if {$h1 ne ""} { break }
            }

            if {$h1 ne ""} {
                lappend ::modvals "api__cluster_fqdn { value '${h1}' }"
            }
            if {($h2 ne "") && [info exists ::m__msdk] && $::m__msdk} {
                lappend ::modvals "api__msdk_api_fqdn { value '${h2}' }"
            }
        }
    } else {
        set web_api_host $::web_api_fqdn
        set msdk_api_host [expr {([string first "\x25\x25\x25" $::msdk_api_fqdn] != 0) ? $::msdk_api_fqdn : ""}]
    }

    mod_val ::advanced_features__serverssl api__serverssl

    mod_val ::advanced_features__snatmode api__snatmode

    new_val ::advanced_features__snatpool api__snatpool

    if {[info exists ::advanced_features__snatmode] &&
            ($::advanced_features__snatmode == 1) &&
                [info exists ::advanced_features__snats]} {

        set tbl [list]
        foreach {row} $::advanced_features__snats {
            set ip [tmsh::get_field_value $row ip]
            if {$ip ne ""} {
                lappend tbl "{ row { '${ip}' } }"
            }
        }

        if {[llength $tbl]} {
            lnew c "modify /sys application service ${::myapp}"
            lappend c "tables modify \x7b"
             lappend c "api__snats \x7b"
              lappend c "column-names { ip }"
              lappend c "rows \x7b"
               lappend c [join $tbl]
              lappend c "\x7d"
             lappend c "\x7d"
            lappend c "\x7d"
            iapp::conf [join $c]
        }
    }

    mod_val ::advanced_features__proxy api__proxy

    new_val ::advanced_features__proxy_auth api__proxy_auth
    new_val ::advanced_features__username api__creds__username
    new_val ::advanced_features__passcode api__creds__passcode

    new_val ::advanced_features__proxy_pool_existing api__proxy_pool_existing

    set proxy_api_host ""
    if {[info exists ::advanced_features__proxy_pool_source] &&
            ($::advanced_features__proxy_pool_source eq "Create New") &&
                [info exists ::advanced_features__proxy_pool_new]} {

        set tbl [list]
        set didfqdn 0
        set didtbl 0
        foreach {row} $::advanced_features__proxy_pool_new {
            set hip [tmsh::get_field_value $row proxy_host_ip]
            set port [tmsh::get_field_value $row proxy_port]
            if {[regexp {[^0-9.%]} $hip]} {
                if {$didfqdn} { continue }

                set proxy_api_host $hip
                lappend ::newvals "api__proxy_pool_fqdn__fqdn { value [tmsh_escape $hip] }"
                lappend ::newvals "api__proxy_pool_fqdn__port { value [tmsh_escape $port] }"
                lappend ::newvals "api__proxy_pool_source { value 'FQDN' }"
                set didfqdn 1
            } else {
                if {!$didtbl} {
                    lappend ::newvals "api__proxy_pool_source { value 'Create New' }"
                    set didtbl 1
                }
                if {($hip eq "") || ($port eq "")} {
                    continue
                }
                lappend tbl "{ row { '${hip}' '${port}' } }"
            }
        }

        if {[llength $tbl]} {
            lnew c "modify /sys application service ${::myapp}"
            lappend c "tables modify \x7b"
             lappend c "api__proxy_pool_ips \x7b"
              lappend c "column-names { proxy_ip proxy_port }"
              lappend c "rows \x7b"
               lappend c [join $tbl]
              lappend c "\x7d"
             lappend c "\x7d"
            lappend c "\x7d"
            iapp::conf [join $c]
        }
    }

    lappend ::modvals "protected_endpoints__handler { value 'iApp (default)' }"
    lappend ::modvals "istl_protected_endpoints__handler { value 'iApp (default)' }"

    lnew c "modify /sys application service ${::myapp}"
    lappend c "variables add \x7b"
     lappend c [join $::newvals]
    lappend c "\x7d"
    iapp::conf [join $c]

    lnew c "modify /sys application service ${::myapp}"
    lappend c "variables modify \x7b"
     lappend c [join $::modvals]
    lappend c "\x7d"
    iapp::conf [join $c]

    clean_303 $web_api_host $msdk_api_host $proxy_api_host
} ; #upgrade_from_303


#*************
#***** Main routine
#*************
if {[info exists ::init__visit] && ($::init__visit == 0)} {
    # thank you very much!

    # upgrading from v3.0.3 ??
    if {[info exists ::protected_endpoints__handler] &&
                    ($::protected_endpoints__handler eq "iApp")} {
        upgrade_from_303
    }

    lnew c "modify /sys application service ${::myapp}"
    lappend c "variables modify \x7b"
     lappend c "init__visit { value '1' }"
    lappend c "\x7d variables add \x7b"
     lappend c "init__noPartns { value '0' }"
     lappend c "hidden__visited { value '1' }"
     lappend c "hidden__my_partn { value /${mypartn} }"
    lappend c "\x7d"
    iapp::conf [join $c]

    return
}

if {$::myTG eq "/Common/none"} {
    if {$::general__clean eq "Yes"} {
        return
    }
    fail "This Application cannot be configured in traffic-group ${::myTG} (please adjust partition default traffic group)"
}

cleanup
if { $::general__clean eq "Yes" } {
    clean_last
    return
}

if {[catch {tmsh::get_status / sys license detail} tmp]} {
    fail "Unable to get BIG-IP license details (${tmp})"
} else {
    set tmp [lindex $tmp 0 2]
    set x [lsearch -exact $tmp features]
    set tmp [lindex $tmp [incr x]]
    set x [lsearch -exact $tmp active]
    set ::bigip_licensed [lindex $tmp [incr x]]
}

# vim: set syntax=tcl :
config

}
    			macro {}
    			presentation{
define choice yesno display "small" default "No" {"Yes", "No"}
define choice enable_disable display "medium" default "Disable" {"Enable", "Disable"}
define choice response_code default "200" display "small" {"200", "201", "202", "204", "303", "304", "307", "400", "401", "403", "404", "405", "406", "412", "415", "500", "501"}

optional ("hide" == "always") {
    section hidden {
        message reminder "PLEASE KEEP version number here UP TO DATE!"
        string my_version display "small" default "3.0.4b"
        string f5console default "XC_Console"
        string visited display "small" default "0"

        string my_partn display "medium" default tcl {
            return [tmsh::pwd]
            # working dir changes to app folder upon first save
        }
        string noPartns display "medium" default tcl {
            return "0"
            # IF YOU RESTORE init.noPartns FEATURE THEN REMEMBER
            # TO REPLACE REFERENCES TO THIS hidden.noPartns with
            # REFERENCES TO init.noPartns THROUGHOUT
        }
    }
}
section topic {
    message introduction "Configure the BIG-IP to work with F5 XC Bot Defense Service in API mode. For detailed information and configuration, see the user guide at https://f5cloudservices.zendesk.com/hc/en-us/articles/1500005614802"
    message version "v3.0.4b"
}

optional (hidden.visited!="1") {
    section init {
        choice visit display "xxlarge" default "0" {
            "No. I will click the FINISHED button now!" => "0"
        }
   optional ("feature"=="restored") {
    optional (hidden.visited!="0" && hidden.my_partn=="/Common") {
        choice noPartns display "xxlarge" default "1" {
            "No. I may use any partitions or route-domains" => "0",
            "Yes. I will use only partition Common and RD-0 (see WARNING)" => "1"
        }
        optional (noPartns=="0") {
            message noptn0 "NOTICE:  If you select this option (or upgrade to this from iApp v3.0.3 or earlier) you may need to manually delete some BIG-IP 'node' components-- see the documentation."
        }
        optional (noPartns=="1") {
            message noptn1 "NOTICE: If you wish to use more partitions or route-domains later you may need to manually delete some BIG-IP 'node' components-- see the documentation."
        }
     }
    }
   }
}

optional (hidden.visited!="1") {
    section bigwarn {
        message warn "Please DO NOT change anything below this point before you click the FINISHED button at the bottom of the page.  Even if something looks incomplete, do not change it at this time.  For both new installations and upgrades from v3.0.3 you MUST click FINISHED now.  After you click the FINISHED button, please RETURN to this tab (Reconfigure) to review and/or update your configuration.  After that you will click FINISHED a second time to implement your configuration."
    }
}

  section general {
    yesno clean
    optional (clean == "No") {
        choice kill_switch display "xxlarge" default "No" {
            "No (default), inspect all requests and apply security policy" => "No",
            "Yes, allow requests to bypass inspection/policy " => "Yes"
        }
        choice filter_body display "xxlarge" default "1" {
            "No, analyze entire (unredacted) web-form contents" => "0",
            "Yes (default), analyze telemetry data but redact other data" => "1"
        }
        choice see_wild_help display "small" default "0" {
            "No" => "0", "Yes" => "1"
        }
    }
  }

  optional (general.clean == "No") {
    optional (general.see_wild_help=="1") {
        section wild {
                message glob "Pattern syntax:  An asterisk * matches any sequence of zero or more characters.  A question-mark ? matches any single character.  To find a word like 'food' in the middle of a string you must put asterisks before and after it like *food*.  That will match both 'bird food' and 'food for birds', but food* (single asterisk) will only match 'food for birds' while plain 'food' (no asterisks) won't match either one.  When a pattern expression fails to match all of the characters in a target string (either exactly or by * or ?) pattern reports no match."
            message regex "Very basic regex syntax:  A period . matches any single character and .* (a period followed by an asterisk) matches any sequence of zero or more characters, whileabcand^pqrmatch respectively any character in or not-in the list;0-7matches digits 0-7 inclusive.  Unlike pattern, by default regex reports partial matches:  the regex 'food' will match both 'bird food' and 'food for birds'.  If you want to prevent a partial match you must use caret ^ at the left and/or dollar-sign $ at the right to force matches at the start or end of the target string; for example, ^food matches 'food for birds' and food$ matches 'bird food' while ^food$ will match only 'food' by itself with nothing preceding or following those four letters.  To match multiple distinct words separate them by pipe symbols | and surround the set with parentheses (), for example, ^(food|drink|toothp.*)$ will match any string which contains exactly 'food' or 'drink' or anything that starts with 'toothp' (like 'toothpick' or 'toothpaste').  Regular expressions have many additional powerful features, like a? to match zero-or-one letter 'a'.  This iApp mostly uses TCL 8.4 Advanced Regular Expression (ARE) syntax, which has too many features to describe fully here (do a web search for 'TCL 8.4 re_syntax').  Javascript (ECMAScript) uses very similar syntax, but differs on a few minor points (do a web search for 'cmcdragonkai regular expression comparison').  For endoint matches (see next line) you should use regex syntax common to TCL and Javascript, except for (?i) which is specially handled for you."
            message remarks "The best-performing way to look for several different words is by using a single regex like (red|blue|green) -- searching separately for each word is much slower.  When using regex beware of partial matching; for example, to match a URL path starting with /mobile you must put ^/mobile, otherwise paths like '/docs/mobile-info.htm' (/mobile in the middle) will also match.  For regex endpoint-matching: (a) to ignore letter-case, prepend (?i) to your expression (even before ^, like this: '(?i)^food'); (b) (apart from (?i) which this iApp handles specially) use only regex syntax common between TCL and Javascript-- the most salient problem is matching at word boundaries: the syntax that works for both TCL and JS is an inverse-character-class containing backslash+w, that is ^xx where xx is replaced by a backslash followed by 'w' (sadly, it is impossible to display that expression directly in this message).  For example, to find the word 'head' by itself, possibly surrounded by punctuation as with '<head>' but NOT embedded in a longer word like 'sleepyhead' or 'headlamp', you could use an expression like (^|^xx)head(^xx|$) (replacing xx with backslash+w)."
        }
    }

    section m {
        choice msdk display "xxlarge" default "0" {
            "No" => "0",
            "Yes (supports F5 XC Mobile SDK for mobile apps)" => "1"
        }
        optional (msdk!="0") {
            table hdrs {
                string name display "medium"
                string value display "xlarge"
            }
            row words {
                string words display "xxlarge"
            }
            message info_words "You may use alternation like (PQR|XYZ) to recognize multiple keywords in request bodies."
            string reload_hdr display "xlarge" default ""
        }
    }

    section js_injection {
        string injection_path display "xxlarge" default "/customer1.js"
        message injection_path_msg "Enter a simple path starting with / or else (if F5 Client Javascript requests must be distinguished by hostname) enter a full URL like 'https://example.com/customer1.js'."
        choice inject_tags display "xxlarge" default "Yes" {
            "Yes" => "Yes",
            "No (origin must place Javascript tags in pages)" => "No"
        }
        optional (inject_tags == "Yes") {
            choice injection_location display "xxlarge" default "After <head>" {"After <head>", "After </title>", "Before first <script>"}
            choice async_enable default "Enable" {"Enable"}
            optional (async_enable == "Enable" && inject_tags == "Yes") {
                choice inject_telemetryjs_in_body display "xxlarge" default "No" {
                    "Yes" => "Yes",
                    "No (inject in same place as F5 Client Javascript tag)" => "No"
                }
            }
            yesno inject_by_endpoint
            optional (inject_by_endpoint == "Yes") {
                ##TODO: message injected_ep_info "Path is pattern-matched.  Query (URI query string) is regex-matched.  Do not put '?' at start of Query expression."
                table injected_ep {
                    string end_point display "xlarge"
                    ##TODO:  string query display "large"
                }
            }

            yesno exclude_endpoint
            optional (exclude_endpoint == "Yes") {
                ##TODO: message excluded_ep_info "Path is pattern-matched.  Query (URI query string) is regex-matched.  Do not put '?' at start of Query expression."
                table excluded_ep {
                    string end_point display "xlarge"
                    ##TODO: string query display "large"
                }
            }
        }

        optional (inject_tags == "No") {
            message snippets_note "When the BIG-IP does NOT inject F5 Client Javascript tags, you must put the following code snippet(s) into your web pages. Replace F5_JS_PATH with the path specified above."
            optional (async_enable == "Enable") {
                message matcher_js_snippet "<script type='text/javascript' src='F5_JS_PATH?matcher'></script>"
                message cache_js_snippet_async_enabled "<script type='text/javascript' src='F5_JS_PATH?cache'></script>"
                message async_js_snippet "<script type='text/javascript' src='F5_JS_PATH?async' async></script>"
            }
            optional (async_enable == "Disable") {
                message cache_js_snippet "<script type='text/javascript' src='F5_JS_PATH'></script>"
            }
        }
    }

    section protected_endpoints {
        choice handler default "iApp (default)" display "large" {"iApp", "iApp (default)"}
        optional (m.msdk=="0") {
            message info_iapp "Host and Path are pattern-matched.  Query (URI query string) is regex-matched.  Do not put '?' at start of Query expression."
            table endpoint_table_iapp {
                string dsthost display "medium"
                string endpoint display "medium"
                string query display "medium"
                yesno ANY
                yesno GET
                choice POST default "No" display "small" {"Yes", "No"}
                yesno PUT
                choice action default "Continue" display "medium" {"Continue", "Redirect", "Block", "Drop"}
            }
        }
        optional (m.msdk!="0") {
            message info_msdkA "For 'Web' Endpoints, MSDK Request ID is ignored."
            message info_msdkB "For 'Both' (Web plus MSDK) Endpoints, if MSDK Request ID is None or (Hdrs/Body) is not matched, the Web Action is taken."
            message info_msdkC "(For MSDK/Both Endpoints, when request comes from Moble SDK, actions Redirect and Drop are converted to Block.)"
            message info_msdk2 "Host and Path are pattern-matched.  Query is regex-matched.  Do not put '?' at start of Query expression."
            table endpoint_table_msdk {
                choice ept display "medium" default "w" {
                    "Web" => "w",
                    "MSDK" => "m",
                    "Both (W+M)" => "wm"
                }
                string dsthost display "medium"
                string endpoint display "medium"
                string query display "medium"
                yesno ANY
                yesno GET
                choice POST default "No" display "small" {"Yes", "No"}
                yesno PUT
                choice action default "Continue" display "medium" {"Continue", "Redirect", "Block", "Drop"}
                choice mid display "small" default "_" {
                    "None" => "_",
                    "Hdrs" => "h",
                    "Body" => "b"
                }
            }
        }
        choice ignore_case display "xxlarge" default "0" {
            "No, use case-sensitive matching (default, standard)" => "0",
            "Yes, ignore letter-case when matching (non-standard)" => "1"
        }
        optional (ignore_case=="1") {
            message ign_warn "Letter-case will be ignored while matching path portion of request URL (for example, path pattern /doc* will match both /document1 and /DOCUMENT1).  To ignore letter-case when matching query string, prepend (?i) to your regular expression."
        }
    }

    section istl_protected_endpoints {
        choice handler default "iApp (default)" display "large" {"iApp", "iApp (default)"}
        message info_iapp "Host and Path are pattern-matched.  Query (URI query string) is regex-matched.  Do not put '?' at start of Query expression."
        table endpoint_table_iapp {
            string dsthost display "medium"
            string endpoint display "medium"
            string query display "medium"
            choice action default "Continue" display "medium" {"Continue", "Redirect", "Block", "Drop"}
        }
        choice ignore_case display "xxlarge" default "0" {
            "No, use case-sensitive matching (default, standard)" => "0",
            "Yes, ignore letter-case when matching (non-standard)" => "1"
        }
        optional (ignore_case=="1") {
            message ign_warn "Letter-case will be ignored while matching path portion of request URL (for example, path pattern /doc* will match both /document1 and /DOCUMENT1).  To ignore letter-case when matching query string, prepend (?i) to your regular expression."
        }
    }

    section mitigation_settings {
        string redirect_path_iApp display "xxlarge"
        row block_data_iApp {
            response_code rc
            string body display "xxlarge" default "<html><head><title>Unavailable</title></head><body>Unavailable</body></html>"
        }
        choice add_header display "xxlarge" default "0" {
            "No, do not add an F5 XC Bot Defense info header" => "0",
            "Yes, add an F5 XC Bot Defense info header to requests sent to origin" => "1"
        }
        optional (add_header=="1") {
            string bot_header_name display "xxlarge" default "X-F5-XC-Bot-Defense"
        }
    }
    section allow {
        message allowlisthelp "Requests from these IP addresses or with these HTTP header name/value pairs will NOT be evaluated."
        table allow_ips {
            string ip display "medium" validator "ipaddress" default ""
        }
        choice allow_adv display "small" default "0" {
            "No" => "0", "Yes" => "1"
        }
        optional (allow_adv=="0") {
            table allow_header {
                string name display "medium"
                string value display "xxlarge"
            }
        }
        optional (allow_adv!="0") {
            message info_allow_hdrs "Header name and value are regex-matched.  Beware of partial matching."
            table allow_hdrs {
                string name display "medium"
                string value display "xlarge"
            }
        }
    }

    section vs_config {
        multichoice vs display "xlarge" tcl {
            set ptn [regsub {^(/[^/]+).*$} [tmsh::pwd] {\1}]
            if {$ptn eq "/Common"} { set ptn "/" }
            set virts [list]
            foreach {virt} [iapp::get_items -list -local -dir $ptn ltm virtual] {
                if {[regexp {F5XCC-.+-(web|msdk)_vs$} $virt]} { continue }
                lappend virts [regsub {^//} $virt {/}]
            }
            set ::choices [join $virts "\n"]
            return [iapp::safe_display ::choices]
        }
        message note "Each virtual server must have an HTTP profile."
    }

    section api {
        string application_id display "xxlarge" default "6a2ebd3125a448869fd92e47d9516b64"
        string timeout display "small" validator "NonNegativeNumber" default "700"

        optional (hidden.f5console=="%%%F5CONSOLE%%%") {
            editchoice cluster_fqdn display "xxlarge" {
                "ibd-webus.fastcache.net", "ibd-webemea.fastcache.net",
                "ibd-webapcj.fastcache.net"
            }
            optional (m.msdk!="0") {
                editchoice msdk_api_fqdn display "xxlarge" {
                    "ibd-mobileus.fastcache.net", "ibd-mobileemea.fastcache.net",
                    "ibd-mobileapac.fastcache.net", "ibd-mobilelatm.fastcache.net"
                }
            }
        }
    optional (hidden.noPartns!="1") {
      optional (hidden.my_partn!="/Common") {
        row ptn {
            string partn display "medium" default tcl {
                return [regsub {^/([^/]+)(/[^/]+)*$} [tmsh::pwd] {\1}]
            }
            string rd display "small" default tcl {
                set bareptn [regsub {^/([^/]+)(/[^/]+)*$} [tmsh::pwd] {\1}]
                return [lindex [tmsh::get_config "/ auth partition ${bareptn} default-route-domain"] [list 0 3 1]]
            }
            string tg display "large" default tcl {
                set ptn [regsub {^(/[^/]+)(/[^/]+)*$} [tmsh::pwd] {\1}]
                return [lindex [tmsh::get_config "/ sys folder ${ptn} traffic-group"] [list 0 3 1]]
            }
        }
      }
      optional (hidden.my_partn=="/Common") {
        message dflrd "In THIS partition (/Common) route domain 0 is the default route domain."
      }
        choice rd display "xxlarge" default "/#dfl#" tcl {
            set bareptn [regsub {^/([^/]+)(/[^/]+)*$} [tmsh::pwd] {\1}]
            set tmp [lindex [tmsh::get_config "/ auth partition ${bareptn} default-route-domain"] [list 0 3 1]]
            regexp {([0-9]+)$} $tmp junk dflrd
            if {$bareptn eq "Common"} {
                set rdetails [list "Route domain 0 (Common)\t/#dfl#"]
                #lappend rdetails [list "Common = 0 (Common)\t/#0#"]
            } else {
                ##set rdetails [list "Current partition default (${dflrd})\t/#dfl#"]
                set rdetails [list "Current partition default\t/#dfl#"]
            }
            set rdnames [iapp::get_items -list net route-domain]
            set rdlist [list]
            foreach {rdname} $rdnames {
             set tmp [tmsh::get_config "/ net route-domain ${rdname} id partition"]
             set id [lindex $tmp [list 0 3 1]]
             if {($bareptn eq "Common") && ($id == 0)} { continue }
             set rdptn [lindex $tmp [list 0 3 3]]
             set rdname [regsub {^/[^/]+/} $rdname {}]
             lappend rdlist [list $id $rdname $rdptn]
            }
            set rdlist [lsort -integer -index 0 $rdlist]
            foreach {tuple} $rdlist {
             foreach {id rdname rdptn} $tuple { break }
             lappend rdetails "${id} = ${rdname} (${rdptn})\t${id}"
            }
            set ::choices [join $rdetails "\n"]
            return [iapp::safe_display ::choices]
        }
        choice ripe display "xxlarge" default "0" {
            "Refresh when needed (default; recommended)" => "0",
            "Force a refresh daily (select only if advised by F5)" => "24"
        }
    }
        choice snatmode display "xxlarge" default "0" {
            "Use SNAT Automap (may limit performance)" => "0",
            "Create a SNAT pool" => "1",
            "Use an existing SNAT pool" => "2"
        }
        optional (snatmode!="0") {
            optional (snatmode=="1") {
                table snats {
                    string ip display "medium" validator "ipaddress" default ""
                }
            }
            optional (snatmode=="2") {
                choice snatpool display "xxlarge" tcl {
                    set ::choices "[iapp::get_items ltm snatpool]"
                    return [iapp::safe_display ::choices]
                }
            }
        }
        choice serverssl display "xxlarge" default "/Common/serverssl" tcl {
            package require iapp 1.3.0
            set ::choices "[iapp::get_items ltm profile server-ssl]"
            return [iapp::safe_display ::choices]
        }
        choice proxy default "No" display "xxlarge" {
            "Yes, use an (explicit) HTTP proxy to connect to API servers" => "Yes",
            "No, connect directly to API servers" => "No"
        }
        optional (proxy == "Yes") {
            choice proxy_auth default "No" display "xxlarge" {
            "No, HTTP proxy does not demand a Proxy-Authentication header" => "No",
            "Yes, send username and password in Proxy-Authentication header" => "Yes"
            }
            optional (proxy_auth == "Yes") {
                row creds {
                    string username display "medium"
                    password passcode display "large"
                }
            }
            choice proxy_pool_source display "xxlarge" default "FQDN" {
                "Create a new pool using a single proxy hostname" => "FQDN",
                "Create a new pool from one or more proxy IP address(es)" => "Create New",
                "Choose an existing proxy pool" => "Use Existing"
            }
            optional (proxy_pool_source=="FQDN") {
                row proxy_pool_fqdn {
                    string fqdn display "xlarge"
                    string port display "small" validator "PortNumber" default ""
                }
                message proxy_pool_msg "(The proxy hostname may resolve to multiple IP addresses.)"
            }
            optional (hidden.visited!="1") {
                table proxy_pool_new {
                    string proxy_host_ip
                    string proxy_port
                }
            }
            optional (proxy_pool_source == "Create New") {
                table proxy_pool_ips {
                    string proxy_ip display "large" validator "ipaddress"
                    string proxy_port display "small" validator "PortNumber" default ""
                }
            }
            optional (proxy_pool_source == "Use Existing") {
                choice proxy_pool_existing display "xxlarge" tcl {
                    package require iapp 1.3.0
                    set ::choices "[iapp::get_items ltm pool]"
                    return [iapp::safe_display ::choices]
                }
            }
        }
    }
  optional (api.proxy!="Yes") {
    section pool {
        choice check display "xxlarge" default "Yes" {
            "Prefer HTTP monitor (favored, but makes non-TLS connections)" => "Yes",
            "Use default monitor (less sensitive but makes no extra connections)" => "No"
        }
        optional (check == "Yes") {

            string port display "small" validator "PortNumber" default "80"
            editchoice url display "xxlarge" default "/sedcloudapi/health" {
                "/sedcloudapi/health"
            }
            string rc display "small" validator "NonNegativeNumber"  default "200"
        }
    }
  }

    optional (hidden.visited!="1") {
        section api_request_settings {
            string cluster_fqdn
            string msdk_api_fqdn
            string application_id
            string timeout
        }
    }

    section advanced_features {
        optional (hidden.visited!="1") {
            string proxy default "No"
            string proxy_auth
            string username
            password passcode
            string proxy_pool_source
            table proxy_pool_new {
                string proxy_host_ip
                string proxy_port
            }
            string proxy_pool_existing
            string snatmode default "0"
            table snats {
                string ip
            }
            string snatpool
            string serverssl
        }

        string vip2vip_ip display "medium" validator "ipaddress" default "203.0.113.1" required
        optional (hidden.my_partn!="/Common") {
            message info_partn_xccip "You must choose a unique IP address in every partition (including /Common)."
        }
        message info_vip2vip "Supply a non-conflicting IP address for F5 XC Connector internal virtual servers. (This IP is required, but is not used as the source or destination of any external network connections)."
        choice xff default "Yes" display "xxlarge" {
            "Yes, replace untrusted X-Forwarded-For sent by client" => "Yes",
            "No, trust and preserve X-Forwarded-For sent by client" => "No"
        }
        optional (xff=="Yes") {
            message note "The HTTP X-Forwarded-For header records the 'real' client IP address as seen by a proxy or NAT gateway.  However, an adversarial client can easily insert a bogus X-Forwarded-For header, so we typically replace X-Forwarded-For at our own security perimeter.  (The BIG-IP LTM HTTP Profile has an option to insert X-Forwarded-For header, so you may not need to do so here.)"
        }
        choice xpct100 display "xxlarge" default "1" {
            "Send prompt 100-Continue (default; more secure; may affect some API's)" => "1",
            "Pass Expect: 100 to origin server (less secure but some API's need this)" => "0"
        }
        choice hsl_use display "xxlarge" default "0" {
            "No, log via BIG-IP syslogd (usually to management-plane files)" => "0",
            "Yes, log via HSL Log Publisher (usually to network log server)" => "1"
        }
        optional (hsl_use=="1") {
            message hsl_info "Configure and select a Log Publisher that sends to one or more Log Destination(s) of type 'Remote High-Speed Log' which in turn send to one or more Pool(s) of external log servers that accept messages in rfc3164 (BSD) syslog format.  TCP Log Destinations usually perform better than UDP.  The only other type of Log Destination that will work properly is 'Management Port', which is similar to 'Remote High-Speed Log' but sends to a single external server via the management VLAN (no Pool) and may harm overall performance."
        }
        optional (hsl_use=="1") {
            choice hsl_pub display "xxlarge" tcl {
                package require iapp 1.3.0
                set ::choices "[iapp::get_items sys log-config publisher]"
                return [iapp::safe_display ::choices]
            }
        }
        choice log_level display "xxlarge" default "error" {
            "Error (log only errors -- default setting)" => "error",
            "Warning (log malicious requests -- HSL use recommended)" => "warning",
            "Info (log all requests -- HSL use recommended)" => "info",
            "Debug (log debugging data -- HSL use recommended)" => "debug"
        }
        optional ((log_level!="error") && (hsl_use!="1")) {
            message hsl_warn "F5 recommends that you use High-Speed Logging (HSL) to send your log data to an external log server.  Logging more than occasional errors to BIG-IP syslogd will cause a high CPU load.  That may be temporarily acceptable for testing or debugging, but will limit overall performance.  External HSL logging incurs very little performance cost."
        }
        choice log_facility display "xxlarge" default "16" {
            "'local0' (default), via HSL or via syslogd to /var/log/ltm" => "16",
            "'local3' via HSL or via syslogd to /var/log/asm" => "19",
            "'user' via HSL or via syslogd to /var/log/user.log" => "1",
            "'ftp' via HSL (no default syslogd file)" => "11",
            "'lpr' via HSL (no default syslogd file)" => "6",
            "'news' via HSL (no default syslogd file)" => "7",
            "'uucp' via HSL (no default syslogd file)" => "8"
        }
        choice log_json display "xxlarge" default "0" {
            "Simple text (legacy format)" => "0",
            "JSON (structured format)" => "1"
        }
        row log_x {
            string hdrs display "xxlarge" default ""
        }
    }
}

text {
    hidden "PLEASE KEEP INFO HERE UP TO DATE"
    hidden.reminder "Reminder"
    hidden.my_version "iApp version"
    hidden.my_partn "iApp partition"
    hidden.f5console "Set to F5 cloud console type like 'F5-XC-CONSOLE'"
    hidden.visited "set after user updates init.visit"
    hidden.noPartns "IF YOU RESTORE init.noPartns THEN USE THAT INSTEAD OF THIS"

    topic "Welcome to the F5 XC Bot Defense Connector (F5 XCC) iApp"
    topic.introduction "Introduction"
    topic.version "Template Version:"

    init "ONE-TIME INSTALL/UPGRADE SETUP"
    init.visit "Have you clicked the FINISHED button yet?"
    #init.noPartns "Will you use ONLY partition Common and route-domain 0 on this BIG-IP?"
    #init.noptn0 "NOTICE"
    #init.noptn1 "NOTICE"

    bigwarn "IMPORTANT - IMPORTANT - IMPORTANT - IMPORTANT - IMPORTANT - IMPORTANT"
    bigwarn.warn "IMPORTANT"

    # **** General ****
    general "General"
    general.clean "Clean Before Deletion"
    general.kill_switch "Do you want to allow all requests to bypass F5 XC Bot Defense inspection?"
    general.filter_body "Do you want to send ONLY telemetry data from web-form request bodies to F5 XC Defense Engine API for analysis?"
    general.see_wild_help "Do you wish to see info about pattern and regular-expression wildcard matching?"

    wild "Information About Wildcard Matching"
    wild.glob "Pattern (* and ?) matching"
    wild.regex "Regular-expression (regex) matching"
    wild.remarks "Remarks"

    # Mobile-SDK
    m "Mobile SDK Options"
    m.msdk "Do you want to enable F5 XC Bot Defense Mobile SDK support?"
    m.hdrs "What headers in requests indicate Mobile SDK client (ID=Hdrs)?"
    m.hdrs.name "Name (regex, ignores case)"
    m.hdrs.value "Value (regex)"
    m.info_words ""
    m.words "What keywords in requests indicate Mobile SDK client (ID=Body)?"
    m.words.words "Keyword(s) in request-body (regex)"
    m.reload_hdr "Mobile SDK Reload Header Name (supplied by F5)"

    # *******
    # ** JavaScript Injection
    # *******
    js_injection "Javascript Injection Configuration"
    js_injection.injection_path "What path or URL should clients load F5 Client Javascript from?"
    js_injection.injection_path_msg "Note"
    js_injection.inject_telemetryjs_in_body "Should telemetry Javascript snippet be injected into <Body> Tag?"
    js_injection.async_enable "Telemetry Javascript injection"
    js_injection.injection_location "Where in web-page should telemetry Javascript snippet be injected?"
    js_injection.inject_by_endpoint "Do you want to choose which pages are injected with F5 Client Javascript tags?"
    ##js_injection.injected_ep_info ""
    js_injection.injected_ep "Which pages (by path) should have F5 Client Javascript tags injected?"
    js_injection.injected_ep.end_point "Path (pattern)"
    ##TODO: js_injection.injected_ep.query "Query"
    js_injection.exclude_endpoint "Do you want to avoid injecting F5 Client Javascript tags into certain pages?"
    ##js_injection.excluded_ep_info ""
    js_injection.excluded_ep "Which pages (by path) should NOT have F5 Client Javascript tags injected?"
    js_injection.excluded_ep.end_point "Path (pattern)"
    ##TODO: js_injection.excluded_ep.query "Query"
    js_injection.inject_tags "Should BIG-IP inject F5 Client Javascript tags?"
    js_injection.snippets_note "Note"
    js_injection.cache_js_snippet_async_enabled "I/O Hook Javascript"
    js_injection.cache_js_snippet "I/O Hook Javascript"
    js_injection.async_js_snippet "Async Telemetry Javascript"
    js_injection.matcher_js_snippet "Matcher Config Javascript"
    # *******
    # ** mitigation settings
    # *******

    mitigation_settings "Define Mitigation Actions"
    mitigation_settings.add_header "Do you want to add a header to requests indicating F5 XC Bot Defense information?"
    mitigation_settings.bot_header_name "Name of header to carry F5 XC Bot Defense information"
    mitigation_settings.redirect_path_iApp "Specify redirect path (302 Location) (mandatory if any endpoint has Action=Redirect)"
    mitigation_settings.block_data_iApp "Specify 'Block' response (mandatory if any endpoint has Action=Block)"
    mitigation_settings.block_data_iApp.rc "Response Code"
    mitigation_settings.block_data_iApp.body "Response Body"

    # *******
    # ** protected_endpoints
    # *******
    protected_endpoints.handler "Mitigation Handler"
    protected_endpoints.info_iapp ""
    protected_endpoints.endpoint_table_iapp "Which client requests should be inspected by F5 XC Bot Defense service and then mitigated?"
    protected_endpoints.endpoint_table_iapp.dsthost "Host"
    protected_endpoints.endpoint_table_iapp.endpoint "Path"
    protected_endpoints.endpoint_table_iapp.query "Query (regex)"
    protected_endpoints.endpoint_table_iapp.action "Action"
    protected_endpoints "F5 XC Bot Defense Protected Endpoints Configuration"
    protected_endpoints.info_msdkA ""
    protected_endpoints.info_msdkB ""
    protected_endpoints.info_msdkC ""
    protected_endpoints.info_msdk2 ""
    protected_endpoints.endpoint_table_msdk "Which client requests should be inspected by F5 XC Bot Defense service and then mitigated?"
    protected_endpoints.endpoint_table_msdk.ept ""
    protected_endpoints.endpoint_table_msdk.dsthost "Host"
    protected_endpoints.endpoint_table_msdk.endpoint "Path"
    protected_endpoints.endpoint_table_msdk.query "Query (regex)"
    protected_endpoints.endpoint_table_msdk.action "Action"
    protected_endpoints.endpoint_table_msdk.mid "MSDK Req ID"
    protected_endpoints.ignore_case "Do you want to ignore letter-case while matching request paths?"
    protected_endpoints.ign_warn ""

    # *******
    # ** istl protected_endpoints
    # *******
    istl_protected_endpoints "Web-Scraping Protection Endpoints"
    istl_protected_endpoints.handler "Mitigation Handler"
    istl_protected_endpoints.info_iapp ""
    istl_protected_endpoints.endpoint_table_iapp "Which client requests should be inspected by F5 XC Bot Defense service and then mitigated?"
    istl_protected_endpoints.endpoint_table_iapp.dsthost "Host"
    istl_protected_endpoints.endpoint_table_iapp.endpoint "Path"
    istl_protected_endpoints.endpoint_table_iapp.query "Query (regex)"
    istl_protected_endpoints.endpoint_table_iapp.action "Action"
    istl_protected_endpoints.ignore_case "Do you want to ignore letter-case while matching request paths?"

    # *******
    # ** Allowed IPS
    # *******
    allow "Allowlisted Entities"
    allow.allowlisthelp "Description"
    allow.allow_ips "IP Address Allowlist"
    allow.allow_ips.ip "IP"
    allow.allow_adv "Use advanced header matching?"
    allow.allow_header "HTTP Header Allowlist"
    allow.allow_header.name "Name (plain)"
    allow.allow_header.value "Value (pattern)"
    allow.info_allow_hdrs ""
    allow.allow_hdrs "HTTP Header Allowlist (advanced)"
    allow.allow_hdrs.name "Name (regex, ignores case)"
    allow.allow_hdrs.value "Value (regex)"

    # ===========================================================
    # =============== vs config Section =======================
    # ===========================================================
    vs_config "Application Virtual Servers"
    vs_config.vs "Which application virtual server(s) do you want to protect?"
    vs_config.note "Note"

    # ===========================================================
    # =============== pool configuration section ================
    pool "F5 XC Defense Engine API Service(s) Health Monitor"
    pool.check "How do you want to monitor API service availability?"
    pool.port "Which TCP port should HTTP monitor query?"
    pool.url "What HTTP path should the monitor query?"
    pool.rc "What HTTP status code means service is available? (default 200)"

    # ===========================================================
    # =============== API Request configuration =================
    # ===========================================================
    api "F5 XC Defense Engine API Service Settings"
    api.application_id "Application ID"
    api.timeout "Timeout value for API response (msec)"
    api.cluster_fqdn "What is the hostname of the F5 XC Web Defense Engine API service?"
    api.msdk_api_fqdn "What is the hostname of the F5 XC Mobile-SDK Defense Engine service?"
    api.ptn "Current partition information (changes here have no effect)"
    api.ptn.partn "Partition name"
    api.ptn.rd "Default route domain"
    api.ptn.tg "Default traffic group"
    api.dflrd ""
    api.rd "Which route domain (RD) is used to reach F5 XC Defense Engine API servers?"
    api.ripe "When should F5 XC Defense Engine API server pools be forcibly refreshed?"
    api.snatmode "What source address(es) (SNAT) should outbound connections to F5 XC Defense Engine API servers use?"
    api.snats "SNAT IP Address(es) for API access"
    api.snats.ip "IP (in selected route-domain or use %RD)"
    api.snatpool "Existing SNAT Pool"
    api.serverssl "What Server SSL Profile should outbound connections to F5 XC Defense Engine API servers use?"
    api.proxy "Should F5 XC Defense Engine API requests go through an HTTP proxy?"
    api.proxy_auth "Does the HTTP proxy require Basic authorization credentials?"
    api.creds "Proxy access credentials"
    api.creds.username "Username"
    api.creds.passcode "Password"
    api.proxy_pool_source "What HTTP proxy pool do you want to use?"
    api.proxy_pool_fqdn "Hostname of proxy"
    api.proxy_pool_fqdn.fqdn "FQDN"
    api.proxy_pool_fqdn.port "Port"
    api.proxy_pool_msg ""
    api.proxy_pool_new "v3.0.3 Proxy Host/IP addresses"
    api.proxy_pool_new.proxy_host_ip "Host/IP (in selected route domain or use %RD)"
    api.proxy_pool_new.proxy_port "Port"
    api.proxy_pool_ips "Proxy IP addresses"
    api.proxy_pool_ips.proxy_ip "IP (in selected route domain or use %RD)"
    api.proxy_pool_ips.proxy_port "Port"
    api.proxy_pool_existing "Select proxy pool"

    # ===========================================================
    # =============== Advanced Features Section =================
    # ===========================================================
    advanced_features "Advanced Features"
    advanced_features.xff "Do you want to update the HTTP X-Forwarded-For header?"
    advanced_features.xpct100 "How should client requests with Expect: 100 header be handled?"
    advanced_features.note ""
    advanced_features.vip2vip_ip "What IP address should F5 XC Connector (this iApp) use for internal virtual servers?"
    advanced_features.info_partn_xccip ""
    advanced_features.info_vip2vip ""
    advanced_features.hsl_use "Do you want to log via HSL?"
    advanced_features.hsl_warn "Warning"
    advanced_features.hsl_info ""
    advanced_features.hsl_pub "HSL log publisher"
    advanced_features.log_level "Log only messages at this severity level or above:"
    advanced_features.log_facility "Which syslog 'facility' do you want to send log messages to?"
    advanced_features.log_json "Use what log-message format? (same data either way)"
    advanced_features.log_x "What request headers (if any) should request log messages include?"
    advanced_features.log_x.hdrs "Header name(s) (regex, ignores case)"
# vim: set syntax=tcl :
}

}
    			role-acl none
    			run-as none
    		}
    	}
    	description none
    	ignore-verification false
    	requires-bigip-version-max none
    	requires-bigip-version-min 14.0.0
    	requires-modules { }
    	signing-key none
    	tmpl-checksum none
    	tmpl-signature none
    }